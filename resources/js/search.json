[[{"i":"#","p":["Learn about the Parsley library and its key features."]},{"l":"Welcome to Parsley","p":["Parsley is an easy-to-use, reflection-based dependency injection package that fits seamlessly into any Go application. It bridges the gap between dependency configuration and service activation, providing automated lifetime management and a clean, organized way to handle dependencies."]},{"l":"Key Features"},{"l":"Type Registration & Resolution","p":["Constructor Functions: Register types via constructor functions and automatically inject dependencies into constructors.","Resolve by Type: Support for both interfaces and pointer types.","Safe Casting: Use ResolveRequiredService[T] for type-safe resolutions.","Lifetime Management: Register types with singleton, scoped, or transient lifetimes.","Validate Service Registrations: Parsley now includes built-in validation for service registrations, prevent runtime errors due to missing or circular dependencies."]},{"l":"Advanced Registrations","p":["Modular Registrations: Bundle registrations into modules for cleaner organization.","Lazy Loading: Dependencies are injected only when needed using Lazy[T].","Custom Factories: Define custom factory functions for dynamic resolution.","Provide to service instance to the resolver: Provide service instances to the resolver that cannnot be automatically constructed."]},{"l":"Multiple Registrations","p":["Named Services: Register and resolve multiple services for the same interface.","Service Lists: Resolve services as a list."]},{"l":"Proxy & Mocking Support","p":["Proxy Services: Generate proxies as drop-in replacements with method interception.","Mock Generation: Create configurable mocks to enhance testing.","Want to know more? Read on to discover how Parsley can enhance your Go application's architecture and maintainability."]}],[{"i":"#","p":["Get started with Parsley by learning how to register and resolve services dynamically. This guide covers the basics of setting up service dependencies, implementing interfaces, and using Parsley’s service registry to structure your application with the Inversion of Control (IoC) design principle."]},{"l":"Quick start","p":["This quick start guide walks you through structuring your application and using Parsley to dynamically register and resolve services (or components) at runtime. In this documentation, the terms services and components are used interchangeably but mean the same thing—object instances of a specific type. To effectively understand dependency mapping in Parsley, let's look at a practical example involving types, interfaces, and constructor methods. Once you are familiar with the basics, you can check out the rest of this documentation for more advanced usage and integration examples."]},{"l":"Structuring the application","p":["Inversion of control (IoC) is a design principle that flips your application's traditional approach to handling dependencies. Instead of having components directly instantiate their dependencies, you structure your application so that dependencies are provided to components at the time of their creation. In Parsley, object instances are created through constructor methods, whereby dependencies are expressed as arguments. This approach decouples your components and promotes more flexible and maintainable code.","In the quick start example, we define a DataService interface and provide two implementations for it. The application maps the constructor functions to the abstraction, and resolves all registered services to call their FetchData method in a loop."]},{"l":"Add the Parsley reference","p":["Use the following command to add a reference to the latest version of the Parsley library to your project:"]},{"l":"Define interfaces","p":["Interfaces in Go are a powerful tool for decoupling dependencies and defining contracts between different components of an application or library. While the Go community often emphasizes composition over inheritance and favors concrete types over interfaces in many scenarios, defining interfaces remains viable, particularly when integrating with existing enterprise patterns - such as dependency injection - from other languages.","In the provided example, DataService is an interface that mandates the implementation of the FetchData method, which should return a string. This contract ensures that any implementing DataService will provide a method to fetch data, regardless of how it is internally implemented (e.g., fetching from a remote server, database, or local storage)."]},{"l":"Create implementation types","p":["Implementation types are the concrete structs that fulfill the contracts defined by the interfaces. If combined with constructor functions (whose return type are interfaces), those structs can be kept private."]},{"l":"Define constructor methods","p":["Constructor methods are responsible for creating instances of the implementation types. These methods specify the dependencies required by the implementation type through their parameters. To keep things simple for now, the services in this example are not dependent on other services, thus the constructor functions do not have any parameters."]},{"l":"Configure dependency mapping in Parsley","p":["With the types, interfaces, and constructor methods defined, you can now configure Parsley to map these dependencies. This involves setting up a service registry and registering the services with appropriate lifetimes. The example below registers the remoteDataService and localDataService types as transient services.","Create a service registry: The NewServiceRegistry function initializes a new service registry, which will hold the configuration for all your service mappings.","Register services: Services are registered with the registry using functions such as RegisterTransient, RegisterScoped, RegisterSingleon and others. In this example, we're registering services using the constructor functions NewRemoteDataService and NewLocalDataService with a transient lifetime behavior, causing the resolver to instanciate services each time they are requested."]},{"l":"Resolve dependencies","p":["Finally, services can be resolved via Parsley. This involves using the resolving package to obtain instances of your services as needed. Here's a more detailed breakdown of the process:","Create a Resolver: The NewResolver function initializes a resolver with the provided registry, which contains the configuration for all your service mappings.","Create a context to manage scoped services: The NewScopedContext function creates a new scope context. A scope context defines the lifetime and scope of the services being resolved. Here, we're using the background context from the context package, which is a common way to initialize a root context in Go.","Resolve the required services: The ResolveRequiredServices[T] function is used to retrieve instances of the specified service type ( DataService in this case). This function requires the resolver and scope context as parameters. It returns a list of object instances compatible with the specified type T and an error, allowing you to handle any issues that might occur during the resolution process."]}],[{"i":"#","p":["Learn how to register services in Parsley using constructor functions. Understand what constructor functions are in Go and how Parsley uses them to automatically resolve and inject dependencies into your application."]},{"l":"Register Constructor Functions","p":["In Parsely, the fundamental way to register services is by providing a constructor function to the service registry. This method enables you to create instances of your services in a controlled manner and inject them into your application as needed."]},{"l":"What is a constructor function?","p":["In Go, a constructor function is a regular function used to initialize and return an instance of a type. It typically follows the pattern NewTypeName and allows for setting up a struct with necessary values or configurations before returning it. Unlike languages with built-in constructors, Go doesn't have special constructor syntax, so developers create these functions explicitly to manage object initialization and ensure type safety. For example, a constructor for the greeter struct might be NewGreeter() *greeter or NewGreeter() Greeter if interfaces are preferred.","When registering a constructor function for a service type, Parsley inspects the given function upon service resolution and automatically determines the required services. Constructor functions must also be registered for required services so that Parsley can construct the whole tree of dependencies and pass service instances as needed."]},{"l":"Example","p":["Here’s a basic example of registering a service using a constructor function:","In this example, the NewGreeter function is used to create instances of the Greeter interface. This function returns an implementation of Greeter while hiding the concrete type *greeter.","The Greeter interface and its implementation are defined as follows:","While it’s possible for NewGreeter to return a *greeter directly, it is generally advisable to return the interface type Greeter. This approach maintains flexibility and abstraction, making it easier to change implementations without modifying dependent code."]}],[{"i":"#","p":["Learn how to use factory functions in Parsley to gain more control over service creation. Discover the difference between factory and constructor functions, and see how factory functions enable dynamic service configuration with additional parameters."]},{"l":"Register Factory Functions","p":["In Parsely, you can register a factory function to provide more control and customization when creating service instances. A factory function differs from a constructor function because it allows you to pass additional parameters to configure the service creation process.","Instead of directly registering a constructor function that returns a service instance, you register a factory function that returns another function. This returned function is then used to create the actual service instances.","Here’s a detailed look at how to register and use a factory function:","Suppose you want to create a Greeter service where the salutation can be customized. You can use a factory function to achieve this. Here’s how you would define and register a factory function:","This is how you use it:"]}],[{"i":"#","p":["Learn how to use the `RegisterInstance` method in Parsley to manually register and manage complex service instances. Ensure consistent state and availability across your application by treating registered instances as singletons, making them accessible to other services as dependencies."]},{"l":"Register Instances","p":["In Parsely, the RegisterInstance method registers a preexisting service instance, particularly useful for objects that cannot be created automatically due to complex configuration, data dependencies, or third-party APIs. Once registered, these instances behave as singletons, meaning the same instance is reused throughout the application. This ensures the registered object is consistently available as a dependency for other services, maintaining consistency and state across your application.","Let's go through the process of registering a service instance manually and using it within your application.","Assume you have an interface DataService and an implementation LocalDataService.","Manually create an instance of the service and register it using RegisterInstance. This method is ideal for instances that require specific configuration or are provided by an external factory. To resolve and use the registered service instance, simply request it from the resolver:","By registering service instances manually, you can integrate complex, pre-configured, or third-party-provided objects into your application, ensuring they are available as dependencies for other services managed by Parsely. This method is handy when dealing with objects that cannot be easily instantiated within the standard service registration flow."]}],[{"i":"#","p":["Learn how to group related services with the `RegisterModule` method in Parsley to maintain modular code structure. Discover how service modules improve code organization, reusability, and separation of concerns, making your applications easier to scale and manage."]},{"l":"Register Service Modules","p":["Parsley provides a convenient way to group related services into modules using the RegisterModule method. This method allows you to register a function that bundles service registrations, making your code more organized and maintainable. Here’s how to use it:"]},{"l":"Benefits","p":["Using RegisterModule offers several benefits. It helps maintain a clean and organized code structure by grouping related services, making the codebase more straightforward to manage.","Modules allow you to define and reuse service groupings across different parts of your application, promoting modularity and reusability. Additionally, this approach keeps the service registration logic separate from the application logic, enhancing the separation of concerns and improving overall code maintainability and clarity as your application scales.","Another use case could be a package that keeps all service implementation types private to the package but exports nothing else, like interfaces and module registration functions. This way, services can be integrated into apps without exposure."]}],[{"i":"#","p":["Learn how to use named service registration in Parsley for precise control over multiple service implementations. Discover how to associate unique names with services, configure different contexts, and resolve them dynamically to create a more flexible and adaptable application architecture."]},{"l":"Register Named Services","p":["In Parsely, you can register services with specific names to support more granular control and flexible resolution of service instances. Named services are beneficial when you need to manage multiple implementations of the same interface or provide different configurations for different contexts.","When registering named services, you associate a unique name with each implementation. This allows you to resolve and retrieve the correct service based on its name, enhancing your application's flexibility and configurability.","Suppose you have an interface DataService with two implementations: remoteDataService and localDataService."]},{"i":"register-named-services-1","l":"Register named services","p":["Register each service with a unique name using RegisterNamed. This allows you to specify different names for each implementation and control their lifecycle.","In this example, RegisterNamed is used to register the constructor functions NewRemoteDataService and NewLocalDataService with the names remote and local, respectively. The LifetimeTransient parameter indicates that each service instance is transient and will be created anew each time it is resolved.","Note Implementation types with names are automatically registered as an unnamed service with the desired interface type and lifetime scope. So, named services can be resolved (separately) by name or as a list of service instances per interface type."]},{"l":"Resolve and use named services","p":["To resolve a named service, you use a factory function that takes the name of the service (a string parameter) and returns an instance of the service along with any errors. This is done through the ResolveRequiredService function:","Note You can combine the concept of factory functions and named services, but you must ensure that the signature of the factory function is the same for all named services."]}],[{"i":"#","p":["Learn how to register and inject multiple services of the same contract type in Parsley using the `RegisterList[T]` method. Simplify service management and gain flexibility by automatically injecting arrays or slices of services that share a common interface or type."]},{"l":"Manage Multiple Service Implementations","p":["Parsley supports registering multiple services under the same contract type, allowing you to inject a list of these services into your application. While you can always resolve multiple services of the same contract using the ResolveRequiredServices[T] method, injecting them as an array or slice requires a list registration via the RegisterList[T] method.","This method facilitates the automatic injection of all registered services that share the same contract type, providing greater flexibility and scalability in managing multiple service implementations."]},{"l":"Example","p":["This example demonstrates registering and injecting a list of services sharing the same contract type using Parsley's RegisterList[T] feature. In the code, two data service constructor functions ( NewLocalDataService and NewRemoteDataService) are registered, and then RegisterList[T] is used to group the service registrations under the DataService contract. Please note that both constructor functions must return the service instances as DataService objects to make this automation work.","The dataAggregationService aggregates data from all registered DataService instances. When fetchAll() is called, it iterates over the injected list of DataService implementations, collects their data, and prints the results.","The printed output confirms that local and remote data services are successfully aggregated and utilized."]},{"l":"Benefits and use cases","p":["This feature is handy when working with multiple implementations of the same service contract, such as aggregating results from various sources or supporting different strategies for a given operation.","The RegisterList[T] method simplifies managing these services and ensures that all relevant implementations are easily accessible in a single injection. This is especially valuable in modular systems or scenarios requiring dynamic extension of service capabilities."]}],[{"i":"#","p":["Discover how to manage service instance lifetimes in Parsley through various lifetime scopes. This guide explains the significance of lifetime settings, detailing how they influence the frequency of constructor or factory method calls and the management of service instances in your application."]},{"l":"Lifetime Scopes in Parsley","p":["Parsley allows you to control the lifetime of your service instances through different lifetime scopes. The lifetime setting determines how often the constructor or factory method of a service registration is called and how instances are managed."]},{"l":"Supported service lifetimes","p":["The following lifetime scopes are supported:","Name","Value","Transient","A new instance is created every time the service is requested.","Scoped","The same instance is reused within a scope.","Singleton","The same instance is reused for all requests. Resolved instances remain valid for the lifetime of the resolver.","Note: Multiple registrations for the same service type can use different lifetime scopes. The same is true for named service registrations."]},{"l":"Convenience Functions","p":["Parsley provides several convenience functions to simplify the registration of services with different lifetimes. These functions allow you to register services with minimal boilerplate and ensure clarity in service management:","RegisterSingleton: Registers a service that will have a single instance throughout the application’s lifetime.","RegisterScoped: Registers services with a new instance per scope (such as a request or session).","RegisterTransient: Registers services that will have a new instance every time they are requested.","Each of these functions accept multiple activator functions, allowing multiple services to be registered in one call."]},{"l":"Example","p":["The following demonstration is based on the greeter example code:","In this example, a factory method (instead of a constructor method) is used to intercept the creation of a service instance and trace an event each time Parsley activates a new Greeter service instance. The traceResolveEventFor method uses reflection to determine the type of the resolved service and traces the type name and pointer to the standard output.","The resolveGreeter factory method is registered with Parsley. The lifetime for Greeter instances is set to LifetimeScoped, instructing the resolver to keep track of instances in the Context given when resolving the service.","The following code attempts to resolve Greeter service instances repeatedly. Since the service factory is assigned with the scoped lifetime behavior and the same context is shared with all calls to the ResolveRequiredService method, the factory function is expected to be called only once.","The example produces the following output:","If a new context is passed to each call of the ResolveRequiredService method, a different behavior can be observed.","Now, for each iteration, a new context is created, thus requiring Parsley to activate a new service instance. The example produces the following output:","If you change the example once again, setting the lifetime behavior for the Greeter service to LifetimeSingleton at registration, ...","... Parsley does not store created instances in the given Context but in the instance cache attached to the resolver itself, resulting in the following output:","Understanding and utilizing lifetime scopes in Parsley allows you to manage service instances effectively. Adjust the lifetime settings based on your application's requirements to optimize performance and resource usage."]}],[{"i":"#","p":["Explore how to use Parsley's `ResolveWithOptions` method to dynamically pass specific instances to the resolver, enhancing your application's flexibility in managing dependencies. This guide demonstrates how to override registered dependencies or inject unregistered instances during resolution."]},{"l":"Passing specific instances to the resolver","p":["Parsley's ResolveWithOptions method allows you to pass specific instances into the resolver, providing certain dependencies dynamically at resolution time. This method is handy when overriding registered dependencies or injecting unregistered instances into your objects.","In the following example, the newClient constructor function registers a client service with a transient lifetime. During the resolution, an existing transport instance is passed to the resolver using WithInstance, ensuring that this specific instance is used for the client's transport dependency.","Parsley's ability to inject specific instances dynamically improves flexibility in managing dependencies and provides greater control over the instantiation process. This feature is particularly beneficial for the following use cases:","Runtime configuration: Dynamically configure services based on runtime conditions by passing specific instances.","Dependency injection in testing: Use mock objects or specific instances during tests to simulate various scenarios without altering the registration setup.","Third-party integrations: Integrate with third-party services or libraries that require preconfigured instances, ensuring they are used as dependencies when needed.","By using ResolveWithOptions, you can push unregistered instances into the resolver, ensuring the correct instances are used when resolving dependencies."]}],[{"i":"#","p":["Discover how to use the `Activate` method in Parsley to create instances of unregistered dependencies dynamically. This guide illustrates how to instantiate objects on-the-fly while leveraging registered services. Learn about practical use cases, including dynamic object creation, managing complex dependencies, and integrating with third-party libraries."]},{"l":"Live services: Activating unregistered dependencies","p":["The Activate method allows you to dynamically create instances using registered services, even if the requested service type is not registered. This approach is helpful for scenarios where you need to instantiate objects on the fly with specific dependencies provided by registered services.","In this example, a Greeter service is registered with a transient lifetime. The Activate method is used to create an instance of the ouchie struct on the fly, consuming the Greeter dependency within the factory function.","This is helpful for use cases like the following:","Dynamic object creation: When you need to create objects that depend on registered services without having to register these objects themselves.","Complex dependencies: For scenarios where objects require a complex set of dependencies that are not straightforward to register individually.","Third-party integrations: When integrating with third-party libraries that require on-the-fly object creation based on dynamically resolved dependencies.","The Activate method allows for flexible and efficient dependency injection by dynamically pulling registered instances from the resolver and injecting them into your factory function, ensuring that your dynamically created objects have the necessary dependencies."]}],[{"i":"#","p":["Explore the concept of lazy proxies in Parsley, a feature that allows for the deferred creation of service instances until they are needed. This guide explains how lazy proxies can optimize performance by managing resource-intensive dependencies effectively."]},{"l":"Lazy Proxies","p":["Parsley supports lazy proxies, a powerful feature that allows for the delayed activation of services. A lazy proxy acts as a placeholder for a dependency, deferring its creation until it’s needed. This is particularly useful for services that are expensive to create or may not always be required immediately.","Once the service is activated, the lazy proxy retains the instance, ensuring that subsequent calls to the Value() method return the same instance. This balances performance and resource management, particularly in complex applications."]},{"l":"Example","p":["In this example, we register a Greeter service using a lazy proxy via the RegisterLazy[T] method. The NewGreeterFactory function is passed as the factory for creating Greeter instances, and the LifetimeTransient scope is used, meaning a new instance would typically be created each time.","However, the Greeter instance is not created immediately using a lazy proxy. Instead, a Lazy[Greeter] proxy is resolved, and the actual Greeter instance is only created when lazy.Value() is called for the first time. This instance is then cached within the proxy, ensuring that the same Greeter object is returned on subsequent calls to Value()."]},{"l":"Benefits and use cases","p":["Lazy proxies are ideal for optimizing the performance of applications where certain dependencies are resource-intensive to create but may not always be needed immediately. By deferring the creation of such dependencies until they are required, you can improve startup times and reduce unnecessary resource consumption.","This feature is especially useful in scenarios involving complex object graphs, optional dependencies, or services that are conditionally used based on runtime factors."]}],[{"i":"#","p":["This article introduces the new `generate mocks` CLI command in Parsley, a feature that simplifies the creation of mock implementations for service interfaces in Go. You’ll learn how to generate mocks quickly, configure their behavior, and assert expectations for method calls within your test suites."]},{"l":"Mocking Made Easy with Parsley","p":["In version v0.9 of Parsley, a powerful new feature is introduced: the generate mocks CLI command. This command generates configurable mock implementations from your service interfaces, making testing faster and more efficient.","In this article, you learn how to use this feature to generate mock objects for interfaces, configure their behavior, and assert expectations for method calls in tests. It also showcases a real-world example of integrating these mocks into your Go test suites."]},{"l":"Why Mocks?","p":["Mock objects are an essential part of writing unit tests. They allow you to replace the real implementations of your services with objects that simulate their behavior, giving you more control over your test environment. With Parsley’s new generate mocks command, you can generate mocks that trace method calls, verify parameters, and count invocations without writing additional boilerplate code."]},{"l":"Defining a Service Interface","p":["Let's begin with a simple service interface, Greeter, which defines two methods: SayHello and SayNothing.","By adding the //go:generate directive at the top, we instruct Parsley’s CLI to generate a mock implementation for this interface."]},{"l":"The Generated Mock Code","p":["After running the parsley-cli generate mocks command, Parsley generates the following mock implementation code. A mock.g.go file is automatically created, and any manual changes will be overwritten if the command is rerun."]},{"l":"Configuring Mocks in Tests","p":["Once the mock has been generated, it can be used in your tests as a drop-in replacement for the actual service. You can configure its behavior by overriding the functions for each method in the interface.","Here’s an example of how to test the GreeterMock type by configuring the behavior of SayHello and using Parsley’s Verify assertion helpers:"]},{"l":"Verifying Method Calls (and Arguments)","p":["The generated mocks automatically trace method calls and allow you to verify how often methods were invoked and with which arguments. Parsley provides a set of powerful assertion helpers to verify method calls:"]},{"l":"Counter verification functions","p":["TimesOnce: Verifies that a method was called exactly once.","TimesNever: Verifies that a method was never called.","TimesExactly: Verifies that a method was called exactly n times."]},{"l":"Argument matching","p":["Exact: Matches arguments exactly.","IsAny: Matches any given argument - use this as a placeholder.","For example, in the test case above:","The mock verifies that SayHello was called once with the exact argument John.","The mock checks that SayHello was never called with the argument Jane.","Lastly, it verifies that SayHello was called exactly twice in total.","Note: You can also provide custom TimesFunc and ArgMatch callbacks to evaluate counter values and method call parameters."]},{"l":"Conclusion","p":["With the new generate mocks command, Parsley makes it easy to create fully configurable and traceable mock objects for your services.","The mock generation feature is especially useful for writing tests, where you want to simulate different service behaviors, verify method calls, and ensure your components interact correctly with each other."]},{"l":"Using Parsley’s generator commands without Runtime Dependency Injection","p":["Parsley’s generator commands, like the generate mocks command, can be used independently of Parsley’s runtime dependency injection. This flexibility allows developers to leverage powerful code generation features, such as creating mock implementations for interfaces, without adopting Parsley’s full DI system.","For instance, you may prefer to manually wire your dependencies in a traditional Go setup while still using Parsley’s mock generation capabilities for testing. This makes Parsley a versatile tool that can be integrated into various workflows, whether or not you choose to use runtime DI for your projects."]}],[{"i":"#","p":["This article explores the advanced dependency injection capabilities offered by the Parsley CLI through its `generate proxy` command. You’ll learn how to automatically generate proxy services and interfaces for your service contracts using `//go:generate` annotations."]},{"l":"Advanced Dependency Injection with generated Proxies","p":["The Parsley CLI introduces a powerful feature for advanced dependency injection through its generate proxy command. This command, combined with //go:generate annotations, automatically generates proxy services and interfaces for your service contracts.","Use the following command to install the parsley-cli utility:"]},{"l":"Example","p":["Consider a Greeter interface and its implementation. By adding the //go:generate parsley-cli generate proxy annotation in your code, you enable the Parsley CLI to generate a corresponding proxy class. This proxy wraps the original service and allows for method interception, enabling additional behavior to be injected around service calls.","The code generator creates a greeter.proxy.g.go that contains a type that also implements the Greeter interface and thus can be used as drop-in replacements for the actual Greeter service. The proxy type supports intercepting method calls, allowing custom logic to be added before or after a method is invoked.","In this example, the GreeterProxy wraps the Greeter service, and any registered MethodInterceptor services can act upon method invocations, adding custom behavior such as logging, validation, or modification of method parameters.","The boilerplate code to register the generated proxies and a custom MethodInterceptor for logging purposes looks as follows:"]},{"l":"Benefits and use cases","p":["Separation of Concerns: Proxies can separate core business logic from cross-cutting concerns like logging or security.","Dynamic Interception: Proxies allow dynamic interception of method calls, making adding or modifying behavior easier without altering the service's core logic.","Extensibility: This feature provides a flexible mechanism to extend the functionality of services, making it ideal for scenarios where services require dynamic behavior adjustments. This advanced feature of Parsley CLI simplifies complex dependency injection scenarios, providing developers with robust tools to manage and extend service behavior effortlessly."]}],[{"i":"#","p":["This article discusses the importance of validating service registrations in Parsley using the built-in `Validator` service. You’ll learn how the Validator helps identify critical issues like missing and circular dependencies, which can lead to runtime errors and application crashes."]},{"l":"Validating Service-Registrations","p":["Parsley provides a Validator service to improve service registration and dependency management by detecting two key issues: missing dependencies and circular dependencies. These configuration issues can be challenging, but the Validator ensures your application's dependency graph is valid. It is an essential tool for enhancing the robustness of service registration and resolution, especially in applications with complex service interactions."]},{"l":"What are missing dependencies?","p":["A missing dependency occurs when a service relies on a constructor function that requires a service (the dependency) that hasn't been registered. In such cases, Parsley will fail to resolve the necessary object at runtime, leading to potential crashes or undefined behavior. Missing dependencies are often overlooked during development, especially in large, complex applications where services are registered in multiple places or based on runtime conditions.","For example, if a service A depends on service B but B isn't registered, this will cause an error during resolution:","With the validator, such omissions are detected early, and a meaningful error message is returned before the application proceeds further."]},{"l":"What are circular dependencies?","p":["A circular dependency happens when two or more services depend on each other, directly or indirectly, creating an endless loop of dependencies. Without proper validation, this can lead to a stack overflow error during resolution, causing the application to crash. Circular dependencies are particularly problematic because they can easily occur unintentionally, especially in large systems where many services interact.","For instance, if service A depends on service B, and service B depends on service A, neither can be resolved because each requires the other to be instantiated first:","Without a validator, such issues may be difficult to diagnose. Parsley's built-in circular dependency check ensures that the problem is caught early, preventing the application from entering a non-operable state. Although the resolver module itself checks for circular dependencies at runtime, the Validator services offers better error messaging and earlier detection."]},{"l":"Example Usage","p":["To validate your service registrations, use the following code:","The validator inspects all registered services in the ServiceRegistry, ensuring that all dependencies are properly resolved and that there are no circular dependencies."]},{"l":"When should the validator be used?","p":["It is recommended that service registrations be validated after the registration of service types is complete. This is also the case after registering services to a linked or scoped service registry during runtime."]},{"l":"Why This Matters","p":["Prevent runtime errors: Detect missing or invalid service registrations early to prevent application crashes.","Improve developer experience: Get clear, actionable error messages, helping you resolve issues quickly.","Avoid circular dependency traps: Protect your application from hard-to-diagnose circular dependencies that can lead to infinite recursion and stack overflow errors. For instance, you can organize application dependencies as modules and verify the modules using unit tests. Use the validator at runtime if dependencies get dynamically registered depending on configuration."]}],[{"i":"#","p":["Learn how to integrate Parsley with Cobra to build a modular and maintainable CLI application. This guide utilizes the cobra-extensions package to implement command handlers with typed services, showcasing how Parsley’s dependency injection enhances your command-line projects."]},{"l":"Walkthrough: Parsley Integration with Cobra","p":["This guide demonstrates how to integrate Parsley with Cobra to build a modular and maintainable CLI application. It leverages the cobra-extension package to implement command handlers based on typed command services, making it a natural fit for Parsley’s dependency injection capabilities."]},{"l":"Project Structure","p":["The code for this example can be found at examples/integrations/cobra it has the following structure:"]},{"l":"Main Application","p":["The cmd/main.go file serves as the application's entry point. Here, the service dependencies are registered using a ServiceRegistry instance. Dependency registration is organized in ModuleFunc methods, keeping the main setup clean. Finally, a *charmer.CommandLineApplication service is resolved, and its Execute method is called to run the application."]},{"l":"Modules","p":["The internal/modules package defines the service configurations required for the CLI setup.","The cobra_module.go module configures the Cobra application and registers it as a singleton service. It also enables the resolution of all *cobra.Command types as a list, which is necessary to populate the Cobra application with registered commands.","The services_module.go registers application-specific services, such as the Greeter service."]},{"l":"Services","p":["The Greeter service in internal/services/greeter.go generates a greeting message based on the provided name and politeness level. This service is used by command handlers to produce responses."]},{"l":"Command Handlers","p":["Command handlers in this example are services that implement the TypedCommand interface, providing structured logic and dependency injection. For instance, the helloCommand service uses Greeter to output personalized greetings. With cobra-extensions and Parsley, command declaration, service resolution, and command logic are consolidated in the same module, making the codebase easier to navigate and maintain."]},{"l":"Running the Application","p":["As configured in the code, the application will start a Cobra application and call it´s Execute method. To run the application, navigate to the root directory and execute the following command:","This should return:","For more details on Parsley, check out the Parsley GitHub repository."]}],[{"i":"#","p":["Learn how to integrate the Parsley dependency injection framework with the GoFiber web framework. Follow this guide to set up a GoFiber application using Parsley, creating a more modular, testable, and maintainable codebase."]},{"l":"Walkthrough: Parsley Integration with GoFiber","p":["This guide demonstrates how to integrate the Parsley dependency injection framework with the GoFiber web framework. By following this example, you'll learn how to set up a GoFiber application with dependency injection managed by Parsley, making your codebase more modular, testable, and maintainable."]},{"l":"Project Structure","p":["The code for this example can be found at examples/integrations/gofiber it has the following structure:","This article describes the project's structure and the purpose of each module in detail."]},{"l":"Main Application","p":["The main entry point of the application is in the cmd/main.go file:","In this file, the RunParsleyApplication function is called to bootstrap the application. It initializes the Parsley application context and configures the GoFiber server with the necessary services and route handlers."]},{"l":"Modules","p":["The modules package contains the service configurations required to set up the GoFiber application. The fiber_module.go module configures the Fiber application and registers it as a singleton service within the Parsley framework:","This configuration ensures that the Fiber instance is initialized and available for dependency injection."]},{"l":"Services","p":["Next, the internal/services/greeter.go file defines the Greeter service, which returns a greeting message based on the provided name and politeness flag.","The Greeter service is registered by the greeter_module.go module."]},{"l":"Route Handlers","p":["In this example, route handlers are also services, structs implementing the RouteHandler interface, which register one or more route handlers with the Fiber application. The interface is defined as follows:","The internal/route_handlers/greeter.go file registers the route handler for the /say-hello endpoint, which returns a greeting message based on the query parameters provided in the request. The logic for the message generation is handled by the Greeter service, which is injected into the NewGreeterRouteHandler method.","The route_handler_module.go file handles the registration of the RouteHandler services themselves.","This configuration ensures that all route handlers the application requires are correctly registered and injected into the Fiber application instance. Since the application service expects a set of route handler services, the RegisterList method must be used to register a list activator for the RouteHandler type."]},{"l":"Application Logic","p":["The internal/application.go file contains the main application service:","This file defines the parsleyApplication struct as the main application service. It registers the route handlers and starts the GoFiber server on port 5502. However, aspects like having the listener port configurable or a graceful server shutdown are omitted here, but they could be addressed here as well."]},{"l":"Running the Application","p":["To run the application, navigate to the root directory and execute the following command:","As configured in the code, the application will start a GoFiber server on http://localhost:5502. You can then access the /say-hello endpoint:","This should return:","For more details on Parsley, check out the Parsley GitHub repository."]}],[{"l":"Licensing Information","p":["The Parsley library is released under the Apache License, Version 2.0. This license allows you to freely use, modify, and distribute the library, provided that certain conditions are met, such as including the original license and a notice of modifications."]},{"l":"Third-Party Dependencies","p":["Apache-2.0","BSD-2-Clause","BSD-3-Clause","For specific license details, please refer to the respective third-party projects, or refer to the automated dependencies listing at deps.dev/go/github.com/matzefriedrich/parsley, or check the linked FOSSA licence compliance report.","FOSSA Status","github.com/matzefriedrich/cobra-extensions","github.com/pkg/errors","github.com/spf13/cobra","github.com/stretchr/testify","golang.org/x/mod","License","MIT","Module","Parsley relies on several open-source libraries, each with its own license. The following table outlines Parsley´s direct dependencies:","v0.29.0","v0.6.0","v0.9.1","v1.10.1","v1.11.1","Version"]},{"l":"License Notices","p":["In compliance with open-source licensing obligations, the Parsley documentation lists all relevant third-party licenses within its documentation. This approach ensures transparency and provides proper attribution to all authors and contributors while avoiding the need to include full copies of each license."]}],[{"i":"#","p":["Official documentation of the Parsley´s \"bootstrap\" package"]},{"l":"bootstrap"},{"l":"Index","p":["Constants","Variables","func RunParsleyApplication(cxt context.Context, appFactoryFunc any, configure ...types.ModuleFunc) error","type Application"]},{"l":"Constants"},{"l":"Variables","p":["ErrCannotRegisterAppFactory is returned when the application factory cannot be registered, indicating an issue with the bootstrap process."]},{"l":"func RunParsleyApplication","p":["RunParsleyApplication initializes and runs the Parsley application lifecycle. It registers the application factory, configures additional modules, resolves the main application instance, and invokes its Run method."]},{"l":"type Application","p":["Application provides an abstract interface for creating and running an application. It primarily facilitates the use of dependency injection for resolving services and the managing application lifecycle."]}],[{"i":"#","p":["Official documentation of the Parsley´s \"features\" package"]},{"l":"features"},{"l":"Index","p":["func (i InterceptorBase) Name() string","func (i InterceptorBase) Position() int","func (m *MockBase) AddFunction(name string, signature string)","func (m *MockBase) TraceMethodCall(name string, arguments ...any)","func (m *MockBase) Verify(name string, times TimesFunc, matches ...ArgMatch) bool","func (m MockFunction) String() string","func (p *ProxyBase) InvokeEnterMethodInterceptors(callContext *MethodCallContext)","func (p *ProxyBase) InvokeExitMethodInterceptors(callContext *MethodCallContext)","func (p *ProxyBase) InvokeMethodErrorInterceptors(callContext *MethodCallContext, returnValues ...interface{})","func (p ParameterInfo) String() string","func (r ReturnValueInfo) String() string","func Exact[T comparable](expected T) ArgMatch","func IsAny() ArgMatch","func NewInterceptorBase(name string, position int) InterceptorBase","func NewMethodCallContext(methodName string, parameters map[string]interface{}) *MethodCallContext","func NewMockBase() MockBase","func NewProxyBase[T any](target T, interceptors []MethodInterceptor) ProxyBase","func RegisterFactory[T any](registry types.ServiceRegistry, scope types.LifetimeScope) error","func RegisterLazy[T any](registry types.ServiceRegistry, activatorFunc func() T, _ types.LifetimeScope) error","func RegisterList[T any](ctx context.Context, registry types.ServiceRegistry) error","func RegisterNamed[T any](ctx context.Context, registry types.ServiceRegistry, services ...registration.NamedServiceRegistrationFunc) error","func TimesAtLeastOnce() TimesFunc","func TimesExactly(n int) TimesFunc","func TimesNever() TimesFunc","func TimesOnce() TimesFunc","type ArgMatch","type FactoryFunc","type Interceptor","type InterceptorBase","type Lazy","type MethodCallContext","type MethodInterceptor","type MockBase","type MockFunction","type ParameterInfo","type ProxyBase","type ReturnValueInfo","type TimesFunc"]},{"l":"func RegisterFactory","p":["RegisterFactory registers a factory function for resolving instances of a specified type with a given lifetime scope."]},{"l":"func RegisterLazy","p":["RegisterLazy registers a lazily-activated service in the service registry using the provided activator function."]},{"l":"func RegisterList","p":["RegisterList registers a function that resolves and returns a list of services of type T with the specified registry."]},{"l":"func RegisterNamed","p":["RegisterNamed registers named services with their respective activator functions and lifetime scopes. It supports dependency injection by associating names with service instances."]},{"l":"type ArgMatch","p":["ArgMatch is a function type used to match an argument against a certain condition during mock function verification."]},{"l":"func Exact","p":["Exact returns an ArgMatch that checks if a given argument is exactly equal to the specified expected value."]},{"l":"func IsAny","p":["IsAny always returns true, enabling it to match any given argument during mock function verification."]},{"l":"type FactoryFunc","p":["FactoryFunc represents a function that creates an instance of type T using a context for dependency resolution."]},{"l":"type Interceptor","p":["Interceptor is a base interface type for defining interceptors that can be used to monitor or alter the behavior of other components."]},{"l":"type InterceptorBase","p":["InterceptorBase serves as a foundational structure for defining interceptors, managing essential data like name and position."]},{"l":"func NewInterceptorBase","p":["NewInterceptorBase creates a new instance of InterceptorBase with the specified name and position for managing interceptor metadata."]},{"l":"func (InterceptorBase) Name","p":["Name retrieves the name of the interceptor, which is useful for identification and debugging purposes."]},{"l":"func (InterceptorBase) Position","p":["Position returns the position of the interceptor, helping determine its order in processing flows within a system."]},{"l":"type Lazy","p":["Lazy represents a type whose value is initialized lazily upon first access, typically to improve performance or manage resources."]},{"l":"type MethodCallContext","p":["MethodCallContext captures the context of a method call, including method name, parameters, and return values."]},{"l":"func NewMethodCallContext","p":["NewMethodCallContext creates a new MethodCallContext instance with the provided method name and parameters."]},{"l":"type MethodInterceptor","p":["MethodInterceptor provides hooks to intercept method execution on a proxy object. It allows entering before method invocations, exiting after method executions, and handling errors during method execution for monitoring or altering behavior."]},{"l":"type MockBase","p":["MockBase is used as a foundational struct to track and manage mocked functions and their call history. It helps in testing by allowing function signature tracking and call verification."]},{"l":"func NewMockBase","p":["NewMockBase initializes and returns an instance of MockBase, ideal for setting up and using mock functions in tests."]},{"l":"func (*MockBase) AddFunction","p":["AddFunction adds a new mock function with the specified name and signature to the MockBase instance."]},{"l":"func (*MockBase) TraceMethodCall","p":["TraceMethodCall logs the invocation of a mocked function with specified arguments to facilitate function call tracking during testing. Before function calls can be tracked, the function must be registered with the MockBase instance; use AddFunction."]},{"l":"func (*MockBase) Verify","p":["Verify checks if a mock function was called a specific number of times, optionally matching provided argument conditions."]},{"l":"type MockFunction","p":["MockFunction provides a structure to represent a mocked function in test scenarios. It allows tracking its calls and signature."]},{"l":"func (MockFunction) String","p":["String returns the signature of the mocked function if it exists, otherwise it returns the function's name."]},{"l":"type ParameterInfo","p":["ParameterInfo represents information about a method parameter, including its value, type, and name. It is used in method interception where parameters need to be inspected or logged."]},{"l":"func (ParameterInfo) String","p":["String returns a formatted string representation of the ParameterInfo, useful for logging and debugging purposes."]},{"l":"type ProxyBase","p":["ProxyBase facilitates method interception by allowing the inclusion of multiple interceptors to target method calls. Typically used to monitor, log, or modify behavior of an object's method execution."]},{"l":"func NewProxyBase","p":["NewProxyBase creates a ProxyBase instance with the provided target and a sorted list of method interceptors. Useful for setting up method interception on the target object."]},{"l":"func (*ProxyBase) InvokeEnterMethodInterceptors","p":["InvokeEnterMethodInterceptors triggers the Enter method on all registered interceptors before the target method executes."]},{"l":"func (*ProxyBase) InvokeExitMethodInterceptors","p":["InvokeExitMethodInterceptors triggers the Exit method of all registered interceptors after the target method completes."]},{"l":"func (*ProxyBase) InvokeMethodErrorInterceptors","p":["InvokeMethodErrorInterceptors intercepts the return values of a method, checks for errors, and triggers OnError for registered interceptors."]},{"l":"type ReturnValueInfo","p":["ReturnValueInfo represents the value and type information of a method's return value, used in method interception."]},{"l":"func (ReturnValueInfo) String","p":["String returns a string representation of ReturnValueInfo, formatting the value and its type for debugging purposes."]},{"l":"type TimesFunc","p":["TimesFunc is used to verify the number of times a mock function is called. It allows flexibility in call count assertions."]},{"l":"func TimesAtLeastOnce","p":["TimesAtLeastOnce returns a TimesFunc that verifies if a mock function is called at least once."]},{"l":"func TimesExactly","p":["TimesExactly returns a TimesFunc that checks if the number of function calls is exactly equal to the specified value."]},{"l":"func TimesNever","p":["TimesNever returns a TimesFunc that ensures the function has never been called, providing a strict zero call condition."]},{"l":"func TimesOnce","p":["TimesOnce returns a TimesFunc that checks if the number of function calls equals one. It is useful for verifying single call assertions."]}],[{"i":"#","p":["Official documentation of the Parsley´s \"registration\" package"]},{"l":"registration"},{"l":"Index","p":["Constants","func CreateServiceActivatorFrom[T any](instance T) (func() T, error)","func CreateServiceRegistration(activatorFunc any, lifetimeScope types.LifetimeScope) (types.ServiceRegistrationSetup, error)","func NamedServiceRegistration(name string, activatorFunc any, scope types.LifetimeScope) NamedServiceRegistrationFunc","func NewDependencyInfo(registration types.ServiceRegistration, instance interface{}, consumer types.DependencyInfo) types.DependencyInfo","func NewMultiRegistryAccessor(registries ...types.ServiceRegistryAccessor) types.ServiceRegistryAccessor","func NewServiceRegistrationList(sequence core.ServiceIdSequence) types.ServiceRegistrationList","func NewServiceRegistrationsValidator() Validator","func NewServiceRegistry() types.ServiceRegistry","func RegisterInstance[T any](registry types.ServiceRegistry, instance T) error","func RegisterScoped(registry SupportsRegisterActivatorFunc, activatorFunc ...any) error","func RegisterSingleton(registry SupportsRegisterActivatorFunc, activatorFunc ...any) error","func RegisterTransient(registry SupportsRegisterActivatorFunc, activatorFunc ...any) error","type NamedServiceRegistrationFunc","type SupportsRegisterActivatorFunc","type Validator","Variables"]},{"l":"Constants"},{"l":"Variables"},{"l":"func CreateServiceActivatorFrom","p":["CreateServiceActivatorFrom creates a service activator function for a given instance of type T."]},{"l":"func CreateServiceRegistration","p":["CreateServiceRegistration creates a service registration instance from the given activator function and lifetime scope."]},{"l":"func NewDependencyInfo","p":["NewDependencyInfo creates a new instance of types.DependencyInfo with the provided service registration, instance, and parent dependency."]},{"l":"func NewMultiRegistryAccessor","p":["NewMultiRegistryAccessor creates a new ServiceRegistryAccessor that aggregates multiple registries."]},{"l":"func NewServiceRegistrationList","p":["NewServiceRegistrationList creates a new service registration list instance."]},{"l":"func NewServiceRegistry","p":["NewServiceRegistry creates a new types.ServiceRegistry instance."]},{"l":"func RegisterInstance","p":["RegisterInstance registers an instance of type T. A registered instance behaves like a service registration with a singleton lifetime scope."]},{"l":"func RegisterScoped","p":["RegisterScoped registers services with a scoped lifetime in the provided service registry."]},{"l":"func RegisterSingleton","p":["RegisterSingleton registers services with a singleton lifetime in the provided service registry."]},{"l":"func RegisterTransient","p":["RegisterTransient registers services with a transient lifetime in the provided service registry."]},{"l":"type NamedServiceRegistrationFunc","p":["NamedServiceRegistrationFunc defines a function that returns a service name, its activator function, and its lifetime scope. This type supports the internal infrastructure."]},{"l":"func NamedServiceRegistration","p":["NamedServiceRegistration registers a service with a specified name, activator function, and lifetime scope."]},{"l":"type SupportsRegisterActivatorFunc","p":["SupportsRegisterActivatorFunc allows the registration of activator functions with different lifetime scopes."]},{"l":"type Validator","p":["Validator defines an interface to validate service registries.."]},{"l":"func NewServiceRegistrationsValidator","p":["NewServiceRegistrationsValidator creates a new Validator instance."]}],[{"i":"#","p":["Official documentation of the Parsley´s \"resolving\" package"]},{"l":"resolving"},{"l":"Index","p":["func Activate[T any](ctx context.Context, resolver types.Resolver, activatorFunc any, options ...types.ResolverOptionsFunc) (T, error)","func NewResolver(registry types.ServiceRegistry) types.Resolver","func NewScopedContext(ctx context.Context) context.Context","func ResolveRequiredService[T any](ctx context.Context, resolver types.Resolver) (T, error)","func ResolveRequiredServices[T any](ctx context.Context, resolver types.Resolver) ([]T, error)","func WithInstance[T any](instance T) types.ResolverOptionsFunc","type NamedServiceResolverActivatorFunc","func CreateNamedServiceResolverActivatorFunc[T any](ctx context.Context) NamedServiceResolverActivatorFunc[T]"]},{"l":"func Activate","p":["Activate attempts to create and return an instance of the requested type using the provided resolver. Use this method to instantiate service objects of unregistered types. The specified activator function can have parameters to demand service instances for registered service types."]},{"l":"func NewResolver","p":["NewResolver creates and returns a new Resolver instance based on the provided ServiceRegistry."]},{"l":"func NewScopedContext","p":["NewScopedContext creates a new context with an associated service instance map, useful for managing service lifetimes within scope."]},{"l":"func ResolveRequiredService","p":["ResolveRequiredService resolves a single service instance of the specified type using the given resolver and context. The method can return the following errors: ErrorCannotResolveService, ErrorAmbiguousServiceInstancesResolved."]},{"l":"func ResolveRequiredServices","p":["ResolveRequiredServices resolves all registered services of a specified type T using the given resolver and context."]},{"l":"func WithInstance","p":["WithInstance Creates a ResolverOptionsFunc that registers a specific instance of a type T with a service registry to be resolved as a singleton."]},{"l":"type NamedServiceResolverActivatorFunc","p":["NamedServiceResolverActivatorFunc defines a function for resolving named services."]},{"l":"func CreateNamedServiceResolverActivatorFunc","p":["CreateNamedServiceResolverActivatorFunc creates a NamedServiceResolverActivatorFunc for resolving named services."]}],[{"i":"#","p":["Official documentation of the Parsley´s \"types\" package"]},{"l":"types"},{"l":"Index","p":["Constants","func (f ParsleyAggregateError) Error() string","func (f ParsleyAggregateError) Errors() []error","func (f ParsleyAggregateError) Is(err error) bool","func (f ParsleyError) Error() string","func (f ParsleyError) Is(err error) bool","func (f ParsleyError) Unwrap() error","func (r *RegistryError) MatchesServiceType(name string) bool","func (r *RegistryError) ServiceTypeName(name string)","func (r *ResolverError) ServiceTypeName(name string)","func (s ServiceKey) String() string","func ForServiceType(serviceType string) ParsleyErrorFunc","func MakeServiceType[T any]() ServiceType","func NewDependencyError(msg string) error","func NewReflectionError(msg string, initializers ...ParsleyErrorFunc) error","func NewRegistryError(msg string, initializers ...ParsleyErrorFunc) error","func NewResolverError(msg string, initializers ...ParsleyErrorFunc) error","func NewServiceKey(value string) ServiceKey","func ServiceTypeFrom(t reflect.Type) ServiceType","func WithAggregatedCause(errs ...error) ParsleyErrorFunc","func WithCause(err error) ParsleyErrorFunc","type DependencyError","type DependencyInfo","type FunctionInfo","type FunctionParameterInfo","type LifetimeScope","type ModuleFunc","type NamedService","type ParsleyAggregateError","type ParsleyError","type ParsleyErrorFunc","type ParsleyErrorWithServiceTypeName","type ReflectionError","type RegistryError","type Resolver","type ResolverError","type ResolverOptionsFunc","type ServiceKey","type ServiceRegistration","type ServiceRegistrationList","type ServiceRegistrationSetup","type ServiceRegistry","type ServiceRegistryAccessor","type ServiceType","Variables"]},{"l":"Constants"},{"l":"Variables"},{"l":"func NewDependencyError","p":["NewDependencyError creates a new DependencyError with the provided message."]},{"l":"func NewReflectionError","p":["NewReflectionError creates a new ReflectionError with a specified message and optional initializers."]},{"l":"func NewRegistryError","p":["NewRegistryError creates a new RegistryError with the given message and initializers to modify the error."]},{"l":"func NewResolverError","p":["NewResolverError creates a new ResolverError with the provided message and applies optional ParsleyErrorFunc initializers."]},{"l":"type DependencyError","p":["DependencyError represents an error that occurs due to a missing or failed dependency. This error type encapsulates a ParsleyError."]},{"l":"type DependencyInfo","p":["DependencyInfo provides functionality to manage dependency information."]},{"l":"type FunctionInfo","p":["FunctionInfo Stores information about a service activator function. This interface supports the internal infrastructure."]},{"l":"type FunctionParameterInfo"},{"l":"type LifetimeScope","p":["LifetimeScope represents the duration for which a service or object instance is retained."]},{"l":"type ModuleFunc","p":["ModuleFunc defines a function used to register services with the given service registry."]},{"l":"type NamedService","p":["NamedService is a generic interface defining a service with a name and an activator function."]},{"l":"type ParsleyAggregateError","p":["ParsleyAggregateError represents an aggregate of multiple errors."]},{"l":"func (ParsleyAggregateError) Error","p":["Error returns the message associated with the ParsleyAggregateError."]},{"l":"func (ParsleyAggregateError) Errors","p":["Errors returns the slice of errors contained within ParsleyAggregateError."]},{"l":"func (ParsleyAggregateError) Is","p":["Is checks if the given error is equivalent to any error within the ParsleyAggregateError."]},{"l":"type ParsleyError","p":["ParsleyError represents an error with an associated message and optional underlying cause."]},{"l":"func (ParsleyError) Error","p":["Error returns the message associated with the ParsleyError."]},{"l":"func (ParsleyError) Is","p":["Is compares the current ParsleyError's message with another error's message to determine if they are the same."]},{"l":"func (ParsleyError) Unwrap","p":["Unwrap returns the underlying cause of the ParsleyError, allowing for error unwrapping functionality."]},{"l":"type ParsleyErrorFunc","p":["ParsleyErrorFunc is a function type that modifies a given error."]},{"l":"func ForServiceType","p":["ForServiceType creates a ParsleyErrorFunc that sets the service type name on errors that implement the ParsleyErrorWithServiceTypeName interface."]},{"l":"func WithAggregatedCause","p":["WithAggregatedCause returns a ParsleyErrorFunc that sets an aggregated error cause with the provided errors."]},{"l":"func WithCause","p":["WithCause wraps a given error within a ParsleyError."]},{"l":"type ParsleyErrorWithServiceTypeName","p":["ParsleyErrorWithServiceTypeName defines an interface for setting the service type name on errors."]},{"l":"type ReflectionError","p":["ReflectionError represents an error specifically related to reflection operations, extending ParsleyError."]},{"l":"type RegistryError","p":["RegistryError represents an error that gets returned for failing registry operations."]},{"l":"func (*RegistryError) MatchesServiceType","p":["MatchesServiceType checks if the service type name of the RegistryError matches the specified name."]},{"l":"func (*RegistryError) ServiceTypeName","p":["ServiceTypeName sets the service type name of the RegistryError."]},{"l":"type Resolver","p":["Resolver provides methods to resolve registered services based on types."]},{"l":"type ResolverError","p":["ResolverError represents an error that gets returned for failing service resolver operations."]},{"l":"func (*ResolverError) ServiceTypeName","p":["ServiceTypeName sets the service type name for the ResolverError instance."]},{"l":"type ResolverOptionsFunc","p":["ResolverOptionsFunc represents a function that configures a service registry used by the resolver."]},{"l":"type ServiceKey","p":["ServiceKey represents a unique key for identifying services in the service registry."]},{"l":"func NewServiceKey","p":["NewServiceKey creates a new ServiceKey with the given value."]},{"l":"func (ServiceKey) String","p":["String Gets the value of the current ServiceKey instance."]},{"l":"type ServiceRegistration","p":["ServiceRegistration represents a service registrations."]},{"l":"type ServiceRegistrationList","p":["ServiceRegistrationList provides functionality to manage a list of service registrations. This interface supports internal infrastructure services."]},{"l":"type ServiceRegistrationSetup","p":["ServiceRegistrationSetup extends ServiceRegistration and supports internal infrastructure services."]},{"l":"type ServiceRegistry","p":["ServiceRegistry provides methods to map service types to activator functions. The service registration organizes and stores the metadata required by the service resolver."]},{"l":"type ServiceRegistryAccessor","p":["ServiceRegistryAccessor provides methods to access and retrieve service registrations from the registry."]},{"l":"type ServiceType","p":["ServiceType represents a service type."]},{"l":"func MakeServiceType","p":["MakeServiceType creates a ServiceType instance for the specified generic type T."]},{"l":"func ServiceTypeFrom","p":["ServiceTypeFrom creates a ServiceType from the given reflect.Type. Supports pointer, interface, function, slice, and struct types. The function panics, if t is of an unsupported kind is given."]}],[{"l":"CLI Reference"},{"l":"parsley-cli","p":["With the Parsley CLI, you can generate boilerplate code for advanced DI features effortlessly Whether you're working with proxies, decorators, or need support for dynamic dependency resolution, Parsley CLI has you covered. Focus on your core business logic while it takes care of the heavy lifting."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli completion- Generate the autocompletion script for the specified shell","parsley-cli generate- Generate boilerplate code for advanced DI features","parsley-cli init- Add Parsley to an application","parsley-cli markdown- Exports Markdown documentation to the specified folder","parsley-cli version- Show the current Parsley CLI version"]}],[{"l":"completion"},{"l":"parsley-cli completion","p":["Generate the autocompletion script for the specified shell"]},{"l":"Synopsis","p":["Generate the autocompletion script for parsley-cli for the specified shell. See each sub-command's help for details on how to use the generated script."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli","parsley-cli completion bash- Generate the autocompletion script for bash","parsley-cli completion fish- Generate the autocompletion script for fish","parsley-cli completion powershell- Generate the autocompletion script for powershell","parsley-cli completion zsh- Generate the autocompletion script for zsh"]}],[{"l":"completion bash"},{"l":"parsley-cli completion bash","p":["Generate the autocompletion script for bash"]},{"l":"Synopsis","p":["Generate the autocompletion script for the bash shell.","This script depends on the 'bash-completion' package. If it is not installed already, you can install it via your OS's package manager.","To load completions in your current shell session:","To load completions for every new session, execute once:"]},{"l":"Linux:"},{"l":"macOS:","p":["You will need to start a new shell for this setup to take effect."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli completion- Generate the autocompletion script for the specified shell"]}],[{"l":"completion fish"},{"l":"parsley-cli completion fish","p":["Generate the autocompletion script for fish"]},{"l":"Synopsis","p":["Generate the autocompletion script for the fish shell.","To load completions in your current shell session:","To load completions for every new session, execute once:","You will need to start a new shell for this setup to take effect."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli completion- Generate the autocompletion script for the specified shell"]}],[{"l":"completion powershell"},{"l":"parsley-cli completion powershell","p":["Generate the autocompletion script for powershell"]},{"l":"Synopsis","p":["Generate the autocompletion script for powershell.","To load completions in your current shell session:","To load completions for every new session, add the output of the above command to your powershell profile."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli completion- Generate the autocompletion script for the specified shell"]}],[{"l":"completion zsh"},{"l":"parsley-cli completion zsh","p":["Generate the autocompletion script for zsh"]},{"l":"Synopsis","p":["Generate the autocompletion script for the zsh shell.","If shell completion is not already enabled in your environment you will need to enable it. You can execute the following once:","To load completions in your current shell session:","To load completions for every new session, execute once:"]},{"l":"Linux:"},{"l":"macOS:","p":["You will need to start a new shell for this setup to take effect."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli completion- Generate the autocompletion script for the specified shell"]}],[{"l":"generate"},{"l":"parsley-cli generate","p":["Generate boilerplate code for advanced DI features"]},{"l":"Synopsis","p":["A command group providing tools for creating boilerplate code to support advanced dependency injection (DI) features. It serves as a hub for related subcommands, such as generating mocks, proxies, or other utility types, streamlining the setup of DI patterns and improving developer productivity in complex Go projects."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli","parsley-cli generate mocks- Generate configurable mocks for interface types.","parsley-cli generate proxy- Generate generic proxy types for method call interception."]}],[{"l":"generate mocks"},{"l":"parsley-cli generate mocks","p":["Generate configurable mocks for interface types."]},{"l":"Synopsis","p":["Generates fully configurable mock implementations for Go interface types. It simplifies the process of creating mocks by analyzing the source code and automatically generating mock structs that adhere to the defined interfaces."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli generate- Generate boilerplate code for advanced DI features"]}],[{"l":"generate proxy"},{"l":"parsley-cli generate proxy","p":["Generate generic proxy types for method call interception."]},{"l":"Synopsis","p":["Generates generic proxy types designed for method call interception on Go interfaces. These proxies act as intermediaries, allowing you to inject custom behavior—such as logging, validation, or transformation—before or after method execution."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli generate- Generate boilerplate code for advanced DI features"]}],[{"l":"init"},{"l":"parsley-cli init","p":["Add Parsley to an application"]},{"l":"Synopsis","p":["Integrates Parsley into an existing application by setting up the necessary scaffolding for dependency injection and code generation. It initializes project configurations, generates essential files, and prepares the application for using Parsley's advanced features."]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli"]}],[{"l":"markdown"},{"l":"parsley-cli markdown","p":["Exports Markdown documentation to the specified folder"]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli"]}],[{"l":"version"},{"l":"parsley-cli version","p":["Show the current Parsley CLI version"]},{"l":"Options"},{"l":"SEE ALSO","p":["parsley-cli"]}]]