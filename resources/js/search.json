[[{"l":"Welcome to the Parsley documentation","p":["Parsley is an easy-to-use reflection-based dependency injection package that fits into any Go application. It bridges the gap between dependency configuration and service activation. Want to know how? Read on."]}],[{"l":"Getting started","p":["The dependency mapping configuration in Parsley requires types, interfaces, and constructor methods - basically, the same things you need to wire dependencies manually."]},{"l":"Dependency mapping configuration","p":["In Parsley, constructor methods (you may also know them as initializers or provider functions) are the centerpiece that defines the mappings between abstractions (interfaces) and implementation types. Dependencies, i.e., the services required by the implementation type, are expressed as function parameters. The return type of a constructor method specifies the abstraction, whereby the method itself is responsible for creating the actual object instance, thus acting as the glue between implementation and interface types.","LetÂ´s move on to the quick start tutorial, which explains the concept in detail."]}],[{"l":"Quick start","p":["To effectively understand dependency mapping in Parsley, let's look at a practical example involving types, interfaces, and constructor methods."]},{"l":"Define interfaces","p":["Interfaces in Go are a powerful tool for decoupling dependencies and defining contracts between different components of an application or library. While the Go community often emphasizes composition over inheritance and favors concrete types over interfaces in many scenarios, defining interfaces remains viable, particularly when integrating with existing enterprise patterns - such as dependency injection - from other languages.","In the provided example, DataService is an interface that mandates the implementation of the FetchData method, which should return a string. This contract ensures that any implementing DataService will provide a method to fetch data, regardless of how it is internally implemented (e.g., fetching from a remote server, database, or local storage)."]},{"l":"Create implementation types","p":["Implementation types are the concrete structs that fulfill the contracts defined by the interfaces. If combined with constructor functions (whose return type are interfaces), those structs can be kept private."]},{"l":"Define constructor methods","p":["Constructor methods are responsible for creating instances of the implementation types. These methods specify the dependencies required by the implementation type through their parameters. To keep things simple for now, the services in this example are not dependent on other services, thus the constructor functions do not have any parameters."]},{"l":"Configure dependency mapping in Parsley","p":["With the types, interfaces, and constructor methods defined, you can now configure Parsley to map these dependencies. This involves setting up a service registry and registering the services with appropriate lifetimes. The example below registers the remoteDataService and localDataService types as transient services.","Create a service registry: The NewServiceRegistry function initializes a new service registry, which will hold the configuration for all your service mappings.","Register services: Services are registered with the registry using functions such as RegisterTransient, RegisterScoped, RegisterSingleon and others. In this example, we're registering services using the constructor functions NewRemoteDataService and NewLocalDataService with a transient lifetime behavior, causing the resolver to instanciate services each time they are requested."]},{"l":"Resolve dependencies","p":["Finally, services can be resolved via Parsley. This involves using the resolving package to obtain instances of your services as needed. Here's a more detailed breakdown of the process:","Create a Resolver: The NewResolver function initializes a resolver with the provided registry, which contains the configuration for all your service mappings.","Create a context to manage scoped services: The NewScopeContext function creates a new scope context. A scope context defines the lifetime and scope of the services being resolved. Here, we're using the background context from the context package, which is a common way to initialize a root context in Go.","Resolve the required services: The ResolveRequiredServices[T] function is used to retrieve instances of the specified service type ( DataService in this case). This function requires the resolver and scope context as parameters. It returns a list of services and an error, allowing you to handle any issues that might occur during the resolution process."]}]]