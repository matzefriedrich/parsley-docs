[[{"l":"Welcome to Parsley","p":["Parsley is an easy-to-use, reflection-based dependency injection package that fits seamlessly into any Go application. It bridges the gap between dependency configuration and service activation, providing automated lifetime management and a clean, organized way to handle dependencies."]},{"l":"Features","p":["Register types via constructor functions: Easily map dependencies using constructor functions.","Resolve objects by type: Supports both interface and pointer types.","Support for various lifetimes: Configure services as singletons, scoped, or transient.","Named service registration: Register multiple implementations and resolve them by name.","Factory function support: Create instances based on runtime parameters.","Module registration: Bundle type registrations as modules for easier management.","Want to know more? Read on to discover how Parsley can enhance your Go application's architecture and maintainability."]}],[{"l":"Quick start","p":["This quick start guide walks you through structuring your application and using Parsley to dynamically register and resolve services (or components) at runtime. In this documentation, the terms services and components are used interchangeably but mean the same thing—object instances of a specific type. To effectively understand dependency mapping in Parsley, let's look at a practical example involving types, interfaces, and constructor methods. Once you are familiar with the basics, you can check out the rest of this documentation for more advanced usage and integration examples."]},{"l":"Structuring the application","p":["Inversion of control (IoC) is a design principle that flips your application's traditional approach to handling dependencies. Instead of having components directly instantiate their dependencies, you structure your application so that dependencies are provided to components at the time of their creation. In Parsley, object instances are created through constructor methods, whereby dependencies are expressed as arguments. This approach decouples your components and promotes more flexible and maintainable code.","In the quick start example, we define a DataService interface and provide two implementations for it. The application maps the constructor functions to the abstraction, and resolves all registered services to call their FetchData method in a loop."]},{"l":"Add the Parsley reference","p":["Use the following command to add a reference to the latest version of the Parsley library to your project:"]},{"l":"Define interfaces","p":["Interfaces in Go are a powerful tool for decoupling dependencies and defining contracts between different components of an application or library. While the Go community often emphasizes composition over inheritance and favors concrete types over interfaces in many scenarios, defining interfaces remains viable, particularly when integrating with existing enterprise patterns - such as dependency injection - from other languages.","In the provided example, DataService is an interface that mandates the implementation of the FetchData method, which should return a string. This contract ensures that any implementing DataService will provide a method to fetch data, regardless of how it is internally implemented (e.g., fetching from a remote server, database, or local storage)."]},{"l":"Create implementation types","p":["Implementation types are the concrete structs that fulfill the contracts defined by the interfaces. If combined with constructor functions (whose return type are interfaces), those structs can be kept private."]},{"l":"Define constructor methods","p":["Constructor methods are responsible for creating instances of the implementation types. These methods specify the dependencies required by the implementation type through their parameters. To keep things simple for now, the services in this example are not dependent on other services, thus the constructor functions do not have any parameters."]},{"l":"Configure dependency mapping in Parsley","p":["With the types, interfaces, and constructor methods defined, you can now configure Parsley to map these dependencies. This involves setting up a service registry and registering the services with appropriate lifetimes. The example below registers the remoteDataService and localDataService types as transient services.","Create a service registry: The NewServiceRegistry function initializes a new service registry, which will hold the configuration for all your service mappings.","Register services: Services are registered with the registry using functions such as RegisterTransient, RegisterScoped, RegisterSingleon and others. In this example, we're registering services using the constructor functions NewRemoteDataService and NewLocalDataService with a transient lifetime behavior, causing the resolver to instanciate services each time they are requested."]},{"l":"Resolve dependencies","p":["Finally, services can be resolved via Parsley. This involves using the resolving package to obtain instances of your services as needed. Here's a more detailed breakdown of the process:","Create a Resolver: The NewResolver function initializes a resolver with the provided registry, which contains the configuration for all your service mappings.","Create a context to manage scoped services: The NewScopedContext function creates a new scope context. A scope context defines the lifetime and scope of the services being resolved. Here, we're using the background context from the context package, which is a common way to initialize a root context in Go.","Resolve the required services: The ResolveRequiredServices[T] function is used to retrieve instances of the specified service type ( DataService in this case). This function requires the resolver and scope context as parameters. It returns a list of object instances compatible with the specified type T and an error, allowing you to handle any issues that might occur during the resolution process."]}],[{"l":"Register Constructor Functions","p":["In Parsely, the fundamental way to register services is by providing a constructor function to the service registry. This method enables you to create instances of your services in a controlled manner and inject them into your application as needed.","Here’s a basic example of registering a service using a constructor function:","In this example, the NewGreeter function is used to create instances of the Greeter interface. This function returns an implementation of Greeter while hiding the concrete type *greeter.","The Greeter interface and its implementation are defined as follows:","While it’s possible for NewGreeter to return a * greeter directly, it is generally advisable to return the interface type Greeter. This approach maintains flexibility and abstraction, making it easier to change implementations without modifying dependent code."]}],[{"l":"Register Factory Functions","p":["In Parsely, you can register a factory function to provide more control and customization when creating service instances. A factory function differs from a constructor function because it allows you to pass additional parameters to configure the service creation process.","Instead of directly registering a constructor function that returns a service instance, you register a factory function that returns another function. This returned function is then used to create the actual service instances.","Here’s a detailed look at how to register and use a factory function:","Suppose you want to create a Greeter service where the salutation can be customized. You can use a factory function to achieve this. Here’s how you would define and register a factory function:","This is how you use it:"]}],[{"l":"Register Instances","p":["In Parsely, the RegisterInstance method registers a preexisting service instance, particularly useful for objects that cannot be created automatically due to complex configuration, data dependencies, or third-party APIs. Once registered, these instances behave as singletons, meaning the same instance is reused throughout the application. This ensures the registered object is consistently available as a dependency for other services, maintaining consistency and state across your application.","Let's go through the process of registering a service instance manually and using it within your application.","Assume you have an interface DataService and an implementation LocalDataService.","Manually create an instance of the service and register it using RegisterInstance. This method is ideal for instances that require specific configuration or are provided by an external factory. To resolve and use the registered service instance, simply request it from the resolver:","By registering service instances manually, you can integrate complex, pre-configured, or third-party-provided objects into your application, ensuring they are available as dependencies for other services managed by Parsely. This method is handy when dealing with objects that cannot be easily instantiated within the standard service registration flow."]}],[{"l":"Register service lists","p":["Parsley supports registering multiple services under the same contract type, allowing you to inject a list of these services into your application. While you can always resolve multiple services of the same contract using the ResolveRequiredServices[T] method, injecting them as an array or slice requires a list registration via the RegisterList[T] method.","This method facilitates the automatic injection of all registered services that share the same contract type, providing greater flexibility and scalability in managing multiple service implementations."]},{"l":"Example","p":["This example demonstrates registering and injecting a list of services sharing the same contract type using Parsley's RegisterList[T] feature. In the code, two data service constructor functions ( NewLocalDataService and NewRemoteDataService) are registered, and then RegisterList[T] is used to group the service registrations under the DataService contract. Please note that both constructor functions must return the service instances as DataService objects to make this automation work.","The dataAggregationService aggregates data from all registered DataService instances. When fetchAll() is called, it iterates over the injected list of DataService implementations, collects their data, and prints the results.","The printed output confirms that local and remote data services are successfully aggregated and utilized."]},{"l":"Benefits and use cases","p":["This feature is handy when working with multiple implementations of the same service contract, such as aggregating results from various sources or supporting different strategies for a given operation.","The RegisterList[T] method simplifies managing these services and ensures that all relevant implementations are easily accessible in a single injection. This is especially valuable in modular systems or scenarios requiring dynamic extension of service capabilities."]}],[{"l":"Register service modules","p":["Parsley provides a convenient way to group related services into modules using the RegisterModule method. This method allows you to register a function that bundles service registrations, making your code more organized and maintainable. Here’s how to use it:"]},{"l":"Benefits","p":["Using RegisterModule offers several benefits. It helps maintain a clean and organized code structure by grouping related services, making the codebase more straightforward to manage.","Modules allow you to define and reuse service groupings across different parts of your application, promoting modularity and reusability. Additionally, this approach keeps the service registration logic separate from the application logic, enhancing the separation of concerns and improving overall code maintainability and clarity as your application scales.","Another use case could be a package that keeps all service implementation types private to the package but exports nothing else, like interfaces and module registration functions. This way, services can be integrated into apps without exposure."]}],[{"l":"Register Named Services","p":["In Parsely, you can register services with specific names to support more granular control and flexible resolution of service instances. Named services are beneficial when you need to manage multiple implementations of the same interface or provide different configurations for different contexts.","When registering named services, you associate a unique name with each implementation. This allows you to resolve and retrieve the correct service based on its name, enhancing your application's flexibility and configurability.","Suppose you have an interface DataService with two implementations: remoteDataService and localDataService."]},{"i":"register-named-services-1","l":"Register named services","p":["Register each service with a unique name using RegisterNamed. This allows you to specify different names for each implementation and control their lifecycle.","In this example, RegisterNamed is used to register the constructor functions NewRemoteDataService and NewLocalDataService with the names remote and local, respectively. The LifetimeTransient parameter indicates that each service instance is transient and will be created anew each time it is resolved.","Note Implementation types with names are automatically registered as an unnamed service with the desired interface type and lifetime scope. So, named services can be resolved (separately) by name or as a list of service instances per interface type."]},{"l":"Resolve and use named services","p":["To resolve a named service, you use a factory function that takes the name of the service (a string parameter) and returns an instance of the service along with any errors. This is done through the ResolveRequiredService function:","Note You can combine the concept of factory functions and named services, but you must ensure that the signature of the factory function is the same for all named services."]}],[{"l":"Lifetime Scopes in Parsley","p":["Parsley allows you to control the lifetime of your service instances through different lifetime scopes. The lifetime setting determines how often the constructor or factory method of a service registration is called and how instances are managed."]},{"l":"Supported service lifetimes","p":["The following lifetime scopes are supported:","Name","Value","Transient","A new instance is created every time the service is requested.","Scoped","The same instance is reused within a scope.","Singleton","The same instance is reused for all requests. Resolved instances remain valid for the lifetime of the resolver.","Note: Multiple registrations for the same service type can use different lifetime scopes. The same is true for named service registrations."]},{"l":"Example","p":["The following demonstration is based on the greeter example code:","In this example, a factory method (instead of a constructor method) is used to intercept the creation of a service instance and trace an event each time Parsley activates a new Greeter service instance. The traceResolveEventFor method uses reflection to determine the type of the resolved service and traces the type name and pointer to the standard output.","The resolveGreeter factory method is registered with Parsley. The lifetime for Greeter instances is set to LifetimeScoped, instructing the resolver to keep track of instances in the Context given when resolving the service.","The following code attempts to resolve Greeter service instances repeatedly. Since the service factory is assigned with the scoped lifetime behavior and the same context is shared with all calls to the ResolveRequiredService method, the factory function is expected to be called only once.","The example produces the following output:","If a new context is passed to each call of the ResolveRequiredService method, a different behavior can be observed.","Now, for each iteration, a new context is created, thus requiring Parsley to activate a new service instance. The example produces the following output:","If you change the example once again, setting the lifetime behavior for the Greeter service to LifetimeSingleton at registration, ...","... Parsley does not store created instances in the given Context but in the instance cache attached to the resolver itself, resulting in the following output:","Understanding and utilizing lifetime scopes in Parsley allows you to manage service instances effectively. Adjust the lifetime settings based on your application's requirements to optimize performance and resource usage."]}],[{"l":"Passing specific instances to the resolver","p":["Parsley's ResolveWithOptions method allows you to pass specific instances into the resolver, providing certain dependencies dynamically at resolution time. This method is handy when overriding registered dependencies or injecting unregistered instances into your objects.","In the following example, the newClient constructor function registers a client service with a transient lifetime. During the resolution, an existing transport instance is passed to the resolver using WithInstance, ensuring that this specific instance is used for the client's transport dependency.","Parsley's ability to inject specific instances dynamically improves flexibility in managing dependencies and provides greater control over the instantiation process. This feature is particularly beneficial for the following use cases:","Runtime configuration: Dynamically configure services based on runtime conditions by passing specific instances.","Dependency injection in testing: Use mock objects or specific instances during tests to simulate various scenarios without altering the registration setup.","Third-party integrations: Integrate with third-party services or libraries that require preconfigured instances, ensuring they are used as dependencies when needed.","By using ResolveWithOptions, you can push unregistered instances into the resolver, ensuring the correct instances are used when resolving dependencies."]}],[{"i":"live-services-activating-unregistered-dependencies","l":"Live services: Activating unregistered dependencies","p":["The Activate method allows you to dynamically create instances using registered services, even if the requested service type is not registered. This approach is helpful for scenarios where you need to instantiate objects on the fly with specific dependencies provided by registered services.","In this example, a Greeter service is registered with a transient lifetime. The Activate method is used to create an instance of the ouchie struct on the fly, consuming the Greeter dependency within the factory function.","This is helpful for use cases like the following:","Dynamic object creation: When you need to create objects that depend on registered services without having to register these objects themselves.","Complex dependencies: For scenarios where objects require a complex set of dependencies that are not straightforward to register individually.","Third-party integrations: When integrating with third-party libraries that require on-the-fly object creation based on dynamically resolved dependencies.","The Activate method allows for flexible and efficient dependency injection by dynamically pulling registered instances from the resolver and injecting them into your factory function, ensuring that your dynamically created objects have the necessary dependencies."]}],[{"l":"Lazy Proxies","p":["Parsley supports lazy proxies, a powerful feature that allows for the delayed activation of services. A lazy proxy acts as a placeholder for a dependency, deferring its creation until it’s needed. This is particularly useful for services that are expensive to create or may not always be required immediately.","Once the service is activated, the lazy proxy retains the instance, ensuring that subsequent calls to the Value() method return the same instance. This balances performance and resource management, particularly in complex applications."]},{"l":"Example","p":["In this example, we register a Greeter service using a lazy proxy via the RegisterLazy[T] method. The NewGreeterFactory function is passed as the factory for creating Greeter instances, and the LifetimeTransient scope is used, meaning a new instance would typically be created each time.","However, the Greeter instance is not created immediately using a lazy proxy. Instead, a Lazy[Greeter] proxy is resolved, and the actual Greeter instance is only created when lazy.Value() is called for the first time. This instance is then cached within the proxy, ensuring that the same Greeter object is returned on subsequent calls to Value()."]},{"l":"Benefits and use cases","p":["Lazy proxies are ideal for optimizing the performance of applications where certain dependencies are resource-intensive to create but may not always be needed immediately. By deferring the creation of such dependencies until they are required, you can improve startup times and reduce unnecessary resource consumption.","This feature is especially useful in scenarios involving complex object graphs, optional dependencies, or services that are conditionally used based on runtime factors."]}],[{"l":"Advanced Dependency Injection with generated Proxies","p":["The Parsley CLI introduces a powerful feature for advanced dependency injection through its generate proxy command. This command, combined with //go:generate annotations, automatically generates proxy services and interfaces for your service contracts.","Use the following command to install the parsley-cli utility:"]},{"l":"Example","p":["Consider a Greeter interface and its implementation. By adding the //go:generate parsley-cli generate proxy annotation in your code, you enable the Parsley CLI to generate a corresponding proxy class. This proxy wraps the original service and allows for method interception, enabling additional behavior to be injected around service calls.","The code generator creates a greeter.proxy.g.go that contains a type that also implements the Greeter interface and thus can be used as drop-in replacements for the actual Greeter service. The proxy type supports intercepting method calls, allowing custom logic to be added before or after a method is invoked.","In this example, the GreeterProxy wraps the Greeter service, and any registered MethodInterceptor services can act upon method invocations, adding custom behavior such as logging, validation, or modification of method parameters.","The boilerplate code to register the generated proxies and a custom MethodInterceptor for logging purposes looks as follows:"]},{"l":"Benefits and use cases","p":["Separation of Concerns: Proxies can separate core business logic from cross-cutting concerns like logging or security.","Dynamic Interception: Proxies allow dynamic interception of method calls, making adding or modifying behavior easier without altering the service's core logic.","Extensibility: This feature provides a flexible mechanism to extend the functionality of services, making it ideal for scenarios where services require dynamic behavior adjustments. This advanced feature of Parsley CLI simplifies complex dependency injection scenarios, providing developers with robust tools to manage and extend service behavior effortlessly."]}]]