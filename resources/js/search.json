[[{"l":"Welcome to the Parsley documentation","p":["Parsley is an easy-to-use reflection-based dependency injection package that fits into any Go application. It bridges the gap between dependency configuration and service activation. Want to know how? Read on."]}],[{"l":"Quick start","p":["This quick start guide walks you through structuring your application and using Parsley to dynamically register and resolve services (or components) at runtime. In this documentation, the terms services and components are used interchangeably but mean the same thing—object instances of a specific type. To effectively understand dependency mapping in Parsley, let's look at a practical example involving types, interfaces, and constructor methods. Once you are familiar with the basics, you can check out the rest of this documentation for more advanced usage and integration examples."]},{"l":"Structuring the application","p":["Inversion of control (IoC) is a design principle that flips your application's traditional approach to handling dependencies. Instead of having components directly instantiate their dependencies, you structure your application so that dependencies are provided to components at the time of their creation. In Parsley, object instances are created through constructor methods, whereby dependencies are expressed as arguments. This approach decouples your components and promotes more flexible and maintainable code.","In the quick start example, we define a DataService interface and provide two implementations for it. The application maps the constructor functions to the abstraction, and resolves all registered services to call their FetchData method in a loop."]},{"l":"Add the Parsley reference","p":["Use the following command to add a reference to the latest version of the Parsley library to your project:"]},{"l":"Define interfaces","p":["Interfaces in Go are a powerful tool for decoupling dependencies and defining contracts between different components of an application or library. While the Go community often emphasizes composition over inheritance and favors concrete types over interfaces in many scenarios, defining interfaces remains viable, particularly when integrating with existing enterprise patterns - such as dependency injection - from other languages.","In the provided example, DataService is an interface that mandates the implementation of the FetchData method, which should return a string. This contract ensures that any implementing DataService will provide a method to fetch data, regardless of how it is internally implemented (e.g., fetching from a remote server, database, or local storage)."]},{"l":"Create implementation types","p":["Implementation types are the concrete structs that fulfill the contracts defined by the interfaces. If combined with constructor functions (whose return type are interfaces), those structs can be kept private."]},{"l":"Define constructor methods","p":["Constructor methods are responsible for creating instances of the implementation types. These methods specify the dependencies required by the implementation type through their parameters. To keep things simple for now, the services in this example are not dependent on other services, thus the constructor functions do not have any parameters."]},{"l":"Configure dependency mapping in Parsley","p":["With the types, interfaces, and constructor methods defined, you can now configure Parsley to map these dependencies. This involves setting up a service registry and registering the services with appropriate lifetimes. The example below registers the remoteDataService and localDataService types as transient services.","Create a service registry: The NewServiceRegistry function initializes a new service registry, which will hold the configuration for all your service mappings.","Register services: Services are registered with the registry using functions such as RegisterTransient, RegisterScoped, RegisterSingleon and others. In this example, we're registering services using the constructor functions NewRemoteDataService and NewLocalDataService with a transient lifetime behavior, causing the resolver to instanciate services each time they are requested."]},{"l":"Resolve dependencies","p":["Finally, services can be resolved via Parsley. This involves using the resolving package to obtain instances of your services as needed. Here's a more detailed breakdown of the process:","Create a Resolver: The NewResolver function initializes a resolver with the provided registry, which contains the configuration for all your service mappings.","Create a context to manage scoped services: The NewScopedContext function creates a new scope context. A scope context defines the lifetime and scope of the services being resolved. Here, we're using the background context from the context package, which is a common way to initialize a root context in Go.","Resolve the required services: The ResolveRequiredServices[T] function is used to retrieve instances of the specified service type ( DataService in this case). This function requires the resolver and scope context as parameters. It returns a list of object instances compatible with the specified type T and an error, allowing you to handle any issues that might occur during the resolution process."]}],[{"l":"Register Constructor Functions","p":["In Parsely, the fundamental way to register services is by providing a constructor function to the service registry. This method enables you to create instances of your services in a controlled manner and inject them into your application as needed.","Here’s a basic example of registering a service using a constructor function:","In this example, the NewGreeter function is used to create instances of the Greeter interface. This function returns an implementation of Greeter while hiding the concrete type *greeter.","The Greeter interface and its implementation are defined as follows:","While it’s possible for NewGreeter to return a * greeter directly, it is generally advisable to return the interface type Greeter. This approach maintains flexibility and abstraction, making it easier to change implementations without modifying dependent code."]}],[{"l":"Register Factory Functions","p":["In Parsely, you can register a factory function to provide more control and customization when creating service instances. A factory function differs from a constructor function because it allows you to pass additional parameters to configure the service creation process.","Instead of directly registering a constructor function that returns a service instance, you register a factory function that returns another function. This returned function is then used to create the actual service instances.","Here’s a detailed look at how to register and use a factory function:","Suppose you want to create a Greeter service where the salutation can be customized. You can use a factory function to achieve this. Here’s how you would define and register a factory function:","This is how you use it:"]}],[{"l":"Register Instances","p":["In Parsely, the RegisterInstance method registers a preexisting service instance, particularly useful for objects that cannot be created automatically due to complex configuration, data dependencies, or third-party APIs. Once registered, these instances behave as singletons, meaning the same instance is reused throughout the application. This ensures the registered object is consistently available as a dependency for other services, maintaining consistency and state across your application.","Let's go through the process of registering a service instance manually and using it within your application.","Assume you have an interface DataService and an implementation LocalDataService.","Manually create an instance of the service and register it using RegisterInstance. This method is ideal for instances that require specific configuration or are provided by an external factory. To resolve and use the registered service instance, simply request it from the resolver:","By registering service instances manually, you can integrate complex, pre-configured, or third-party-provided objects into your application, ensuring they are available as dependencies for other services managed by Parsely. This method is handy when dealing with objects that cannot be easily instantiated within the standard service registration flow."]}],[{"l":"Register Named Services","p":["In Parsely, you can register services with specific names to support more granular control and flexible resolution of service instances. Named services are beneficial when you need to manage multiple implementations of the same interface or provide different configurations for different contexts.","When registering named services, you associate a unique name with each implementation. This allows you to resolve and retrieve the correct service based on its name, enhancing your application's flexibility and configurability.","Suppose you have an interface DataService with two implementations: remoteDataService and localDataService."]},{"i":"register-named-services-1","l":"Register named services","p":["Register each service with a unique name using RegisterNamed. This allows you to specify different names for each implementation and control their lifecycle.","In this example, RegisterNamed is used to register the constructor functions NewRemoteDataService and NewLocalDataService with the names remote and local, respectively. The LifetimeTransient parameter indicates that each service instance is transient and will be created anew each time it is resolved.","Note Implementation types with names are automatically registered as an unnamed service with the desired interface type and lifetime scope. So, named services can be resolved (separately) by name or as a list of service instances per interface type."]},{"l":"Resolve and use named services","p":["To resolve a named service, you use a factory function that takes the name of the service (a string parameter) and returns an instance of the service along with any errors. This is done through the ResolveRequiredService function:","Note You can combine the concept of factory functions and named services, but you must ensure that the signature of the factory function is the same for all named services."]}]]