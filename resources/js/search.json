[[{"l":"Welcome to Parsley","p":["Parsley is an easy-to-use, reflection-based dependency injection package that fits seamlessly into any Go application. It bridges the gap between dependency configuration and service activation, providing automated lifetime management and a clean, organized way to handle dependencies."]},{"l":"Key Features"},{"i":"type-registration--resolution","l":"Type Registration & Resolution","p":["Constructor Functions: Register types via constructor functions and automatically inject dependencies into constructors.","Resolve by Type: Support for both interfaces and pointer types.","Safe Casting: Use ResolveRequiredService[T] for type-safe resolutions.","Lifetime Management: Register types with singleton, scoped, or transient lifetimes."]},{"l":"Advanced Registrations","p":["Modular Registrations: Bundle registrations into modules for cleaner organization.","Lazy Loading: Dependencies are injected only when needed using Lazy[T].","Custom Factories: Define custom factory functions for dynamic resolution.","Provide to service instance to the resolver: Provide service instances to the resolver that cannnot be automatically constructed."]},{"l":"Multiple Registrations","p":["Named Services: Register and resolve multiple services for the same interface.","Service Lists: Resolve services as a list."]},{"i":"proxy--mocking-support","l":"Proxy & Mocking Support","p":["Proxy Services: Generate proxies as drop-in replacements with method interception.","Mock Generation: Create configurable mocks to enhance testing.","Want to know more? Read on to discover how Parsley can enhance your Go application's architecture and maintainability."]}],[{"l":"Quick start","p":["This quick start guide walks you through structuring your application and using Parsley to dynamically register and resolve services (or components) at runtime. In this documentation, the terms services and components are used interchangeably but mean the same thing—object instances of a specific type. To effectively understand dependency mapping in Parsley, let's look at a practical example involving types, interfaces, and constructor methods. Once you are familiar with the basics, you can check out the rest of this documentation for more advanced usage and integration examples."]},{"l":"Structuring the application","p":["Inversion of control (IoC) is a design principle that flips your application's traditional approach to handling dependencies. Instead of having components directly instantiate their dependencies, you structure your application so that dependencies are provided to components at the time of their creation. In Parsley, object instances are created through constructor methods, whereby dependencies are expressed as arguments. This approach decouples your components and promotes more flexible and maintainable code.","In the quick start example, we define a DataService interface and provide two implementations for it. The application maps the constructor functions to the abstraction, and resolves all registered services to call their FetchData method in a loop."]},{"l":"Add the Parsley reference","p":["Use the following command to add a reference to the latest version of the Parsley library to your project:"]},{"l":"Define interfaces","p":["Interfaces in Go are a powerful tool for decoupling dependencies and defining contracts between different components of an application or library. While the Go community often emphasizes composition over inheritance and favors concrete types over interfaces in many scenarios, defining interfaces remains viable, particularly when integrating with existing enterprise patterns - such as dependency injection - from other languages.","In the provided example, DataService is an interface that mandates the implementation of the FetchData method, which should return a string. This contract ensures that any implementing DataService will provide a method to fetch data, regardless of how it is internally implemented (e.g., fetching from a remote server, database, or local storage)."]},{"l":"Create implementation types","p":["Implementation types are the concrete structs that fulfill the contracts defined by the interfaces. If combined with constructor functions (whose return type are interfaces), those structs can be kept private."]},{"l":"Define constructor methods","p":["Constructor methods are responsible for creating instances of the implementation types. These methods specify the dependencies required by the implementation type through their parameters. To keep things simple for now, the services in this example are not dependent on other services, thus the constructor functions do not have any parameters."]},{"l":"Configure dependency mapping in Parsley","p":["With the types, interfaces, and constructor methods defined, you can now configure Parsley to map these dependencies. This involves setting up a service registry and registering the services with appropriate lifetimes. The example below registers the remoteDataService and localDataService types as transient services.","Create a service registry: The NewServiceRegistry function initializes a new service registry, which will hold the configuration for all your service mappings.","Register services: Services are registered with the registry using functions such as RegisterTransient, RegisterScoped, RegisterSingleon and others. In this example, we're registering services using the constructor functions NewRemoteDataService and NewLocalDataService with a transient lifetime behavior, causing the resolver to instanciate services each time they are requested."]},{"l":"Resolve dependencies","p":["Finally, services can be resolved via Parsley. This involves using the resolving package to obtain instances of your services as needed. Here's a more detailed breakdown of the process:","Create a Resolver: The NewResolver function initializes a resolver with the provided registry, which contains the configuration for all your service mappings.","Create a context to manage scoped services: The NewScopedContext function creates a new scope context. A scope context defines the lifetime and scope of the services being resolved. Here, we're using the background context from the context package, which is a common way to initialize a root context in Go.","Resolve the required services: The ResolveRequiredServices[T] function is used to retrieve instances of the specified service type ( DataService in this case). This function requires the resolver and scope context as parameters. It returns a list of object instances compatible with the specified type T and an error, allowing you to handle any issues that might occur during the resolution process."]}],[{"l":"Register Constructor Functions","p":["In Parsely, the fundamental way to register services is by providing a constructor function to the service registry. This method enables you to create instances of your services in a controlled manner and inject them into your application as needed.","Here’s a basic example of registering a service using a constructor function:","In this example, the NewGreeter function is used to create instances of the Greeter interface. This function returns an implementation of Greeter while hiding the concrete type *greeter.","The Greeter interface and its implementation are defined as follows:","While it’s possible for NewGreeter to return a * greeter directly, it is generally advisable to return the interface type Greeter. This approach maintains flexibility and abstraction, making it easier to change implementations without modifying dependent code."]}],[{"l":"Register Factory Functions","p":["In Parsely, you can register a factory function to provide more control and customization when creating service instances. A factory function differs from a constructor function because it allows you to pass additional parameters to configure the service creation process.","Instead of directly registering a constructor function that returns a service instance, you register a factory function that returns another function. This returned function is then used to create the actual service instances.","Here’s a detailed look at how to register and use a factory function:","Suppose you want to create a Greeter service where the salutation can be customized. You can use a factory function to achieve this. Here’s how you would define and register a factory function:","This is how you use it:"]}],[{"l":"Register Instances","p":["In Parsely, the RegisterInstance method registers a preexisting service instance, particularly useful for objects that cannot be created automatically due to complex configuration, data dependencies, or third-party APIs. Once registered, these instances behave as singletons, meaning the same instance is reused throughout the application. This ensures the registered object is consistently available as a dependency for other services, maintaining consistency and state across your application.","Let's go through the process of registering a service instance manually and using it within your application.","Assume you have an interface DataService and an implementation LocalDataService.","Manually create an instance of the service and register it using RegisterInstance. This method is ideal for instances that require specific configuration or are provided by an external factory. To resolve and use the registered service instance, simply request it from the resolver:","By registering service instances manually, you can integrate complex, pre-configured, or third-party-provided objects into your application, ensuring they are available as dependencies for other services managed by Parsely. This method is handy when dealing with objects that cannot be easily instantiated within the standard service registration flow."]}],[{"l":"Register service lists","p":["Parsley supports registering multiple services under the same contract type, allowing you to inject a list of these services into your application. While you can always resolve multiple services of the same contract using the ResolveRequiredServices[T] method, injecting them as an array or slice requires a list registration via the RegisterList[T] method.","This method facilitates the automatic injection of all registered services that share the same contract type, providing greater flexibility and scalability in managing multiple service implementations."]},{"l":"Example","p":["This example demonstrates registering and injecting a list of services sharing the same contract type using Parsley's RegisterList[T] feature. In the code, two data service constructor functions ( NewLocalDataService and NewRemoteDataService) are registered, and then RegisterList[T] is used to group the service registrations under the DataService contract. Please note that both constructor functions must return the service instances as DataService objects to make this automation work.","The dataAggregationService aggregates data from all registered DataService instances. When fetchAll() is called, it iterates over the injected list of DataService implementations, collects their data, and prints the results.","The printed output confirms that local and remote data services are successfully aggregated and utilized."]},{"l":"Benefits and use cases","p":["This feature is handy when working with multiple implementations of the same service contract, such as aggregating results from various sources or supporting different strategies for a given operation.","The RegisterList[T] method simplifies managing these services and ensures that all relevant implementations are easily accessible in a single injection. This is especially valuable in modular systems or scenarios requiring dynamic extension of service capabilities."]}],[{"l":"Register service modules","p":["Parsley provides a convenient way to group related services into modules using the RegisterModule method. This method allows you to register a function that bundles service registrations, making your code more organized and maintainable. Here’s how to use it:"]},{"l":"Benefits","p":["Using RegisterModule offers several benefits. It helps maintain a clean and organized code structure by grouping related services, making the codebase more straightforward to manage.","Modules allow you to define and reuse service groupings across different parts of your application, promoting modularity and reusability. Additionally, this approach keeps the service registration logic separate from the application logic, enhancing the separation of concerns and improving overall code maintainability and clarity as your application scales.","Another use case could be a package that keeps all service implementation types private to the package but exports nothing else, like interfaces and module registration functions. This way, services can be integrated into apps without exposure."]}],[{"l":"Register Named Services","p":["In Parsely, you can register services with specific names to support more granular control and flexible resolution of service instances. Named services are beneficial when you need to manage multiple implementations of the same interface or provide different configurations for different contexts.","When registering named services, you associate a unique name with each implementation. This allows you to resolve and retrieve the correct service based on its name, enhancing your application's flexibility and configurability.","Suppose you have an interface DataService with two implementations: remoteDataService and localDataService."]},{"i":"register-named-services-1","l":"Register named services","p":["Register each service with a unique name using RegisterNamed. This allows you to specify different names for each implementation and control their lifecycle.","In this example, RegisterNamed is used to register the constructor functions NewRemoteDataService and NewLocalDataService with the names remote and local, respectively. The LifetimeTransient parameter indicates that each service instance is transient and will be created anew each time it is resolved.","Note Implementation types with names are automatically registered as an unnamed service with the desired interface type and lifetime scope. So, named services can be resolved (separately) by name or as a list of service instances per interface type."]},{"l":"Resolve and use named services","p":["To resolve a named service, you use a factory function that takes the name of the service (a string parameter) and returns an instance of the service along with any errors. This is done through the ResolveRequiredService function:","Note You can combine the concept of factory functions and named services, but you must ensure that the signature of the factory function is the same for all named services."]}],[{"l":"Lifetime Scopes in Parsley","p":["Parsley allows you to control the lifetime of your service instances through different lifetime scopes. The lifetime setting determines how often the constructor or factory method of a service registration is called and how instances are managed."]},{"l":"Supported service lifetimes","p":["The following lifetime scopes are supported:","Name","Value","Transient","A new instance is created every time the service is requested.","Scoped","The same instance is reused within a scope.","Singleton","The same instance is reused for all requests. Resolved instances remain valid for the lifetime of the resolver.","Note: Multiple registrations for the same service type can use different lifetime scopes. The same is true for named service registrations."]},{"l":"Example","p":["The following demonstration is based on the greeter example code:","In this example, a factory method (instead of a constructor method) is used to intercept the creation of a service instance and trace an event each time Parsley activates a new Greeter service instance. The traceResolveEventFor method uses reflection to determine the type of the resolved service and traces the type name and pointer to the standard output.","The resolveGreeter factory method is registered with Parsley. The lifetime for Greeter instances is set to LifetimeScoped, instructing the resolver to keep track of instances in the Context given when resolving the service.","The following code attempts to resolve Greeter service instances repeatedly. Since the service factory is assigned with the scoped lifetime behavior and the same context is shared with all calls to the ResolveRequiredService method, the factory function is expected to be called only once.","The example produces the following output:","If a new context is passed to each call of the ResolveRequiredService method, a different behavior can be observed.","Now, for each iteration, a new context is created, thus requiring Parsley to activate a new service instance. The example produces the following output:","If you change the example once again, setting the lifetime behavior for the Greeter service to LifetimeSingleton at registration, ...","... Parsley does not store created instances in the given Context but in the instance cache attached to the resolver itself, resulting in the following output:","Understanding and utilizing lifetime scopes in Parsley allows you to manage service instances effectively. Adjust the lifetime settings based on your application's requirements to optimize performance and resource usage."]}],[{"l":"Passing specific instances to the resolver","p":["Parsley's ResolveWithOptions method allows you to pass specific instances into the resolver, providing certain dependencies dynamically at resolution time. This method is handy when overriding registered dependencies or injecting unregistered instances into your objects.","In the following example, the newClient constructor function registers a client service with a transient lifetime. During the resolution, an existing transport instance is passed to the resolver using WithInstance, ensuring that this specific instance is used for the client's transport dependency.","Parsley's ability to inject specific instances dynamically improves flexibility in managing dependencies and provides greater control over the instantiation process. This feature is particularly beneficial for the following use cases:","Runtime configuration: Dynamically configure services based on runtime conditions by passing specific instances.","Dependency injection in testing: Use mock objects or specific instances during tests to simulate various scenarios without altering the registration setup.","Third-party integrations: Integrate with third-party services or libraries that require preconfigured instances, ensuring they are used as dependencies when needed.","By using ResolveWithOptions, you can push unregistered instances into the resolver, ensuring the correct instances are used when resolving dependencies."]}],[{"i":"live-services-activating-unregistered-dependencies","l":"Live services: Activating unregistered dependencies","p":["The Activate method allows you to dynamically create instances using registered services, even if the requested service type is not registered. This approach is helpful for scenarios where you need to instantiate objects on the fly with specific dependencies provided by registered services.","In this example, a Greeter service is registered with a transient lifetime. The Activate method is used to create an instance of the ouchie struct on the fly, consuming the Greeter dependency within the factory function.","This is helpful for use cases like the following:","Dynamic object creation: When you need to create objects that depend on registered services without having to register these objects themselves.","Complex dependencies: For scenarios where objects require a complex set of dependencies that are not straightforward to register individually.","Third-party integrations: When integrating with third-party libraries that require on-the-fly object creation based on dynamically resolved dependencies.","The Activate method allows for flexible and efficient dependency injection by dynamically pulling registered instances from the resolver and injecting them into your factory function, ensuring that your dynamically created objects have the necessary dependencies."]}],[{"l":"Lazy Proxies","p":["Parsley supports lazy proxies, a powerful feature that allows for the delayed activation of services. A lazy proxy acts as a placeholder for a dependency, deferring its creation until it’s needed. This is particularly useful for services that are expensive to create or may not always be required immediately.","Once the service is activated, the lazy proxy retains the instance, ensuring that subsequent calls to the Value() method return the same instance. This balances performance and resource management, particularly in complex applications."]},{"l":"Example","p":["In this example, we register a Greeter service using a lazy proxy via the RegisterLazy[T] method. The NewGreeterFactory function is passed as the factory for creating Greeter instances, and the LifetimeTransient scope is used, meaning a new instance would typically be created each time.","However, the Greeter instance is not created immediately using a lazy proxy. Instead, a Lazy[Greeter] proxy is resolved, and the actual Greeter instance is only created when lazy.Value() is called for the first time. This instance is then cached within the proxy, ensuring that the same Greeter object is returned on subsequent calls to Value()."]},{"l":"Benefits and use cases","p":["Lazy proxies are ideal for optimizing the performance of applications where certain dependencies are resource-intensive to create but may not always be needed immediately. By deferring the creation of such dependencies until they are required, you can improve startup times and reduce unnecessary resource consumption.","This feature is especially useful in scenarios involving complex object graphs, optional dependencies, or services that are conditionally used based on runtime factors."]}],[{"l":"Mocking Made Easy with Parsley","p":["In version v0.9 of Parsley, a powerful new feature is introduced: the generate mocks CLI command. This command generates configurable mock implementations from your service interfaces, making testing faster and more efficient.","In this article, you learn how to use this feature to generate mock objects for interfaces, configure their behavior, and assert expectations for method calls in tests. It also showcases a real-world example of integrating these mocks into your Go test suites."]},{"i":"why-mocks","l":"Why Mocks?","p":["Mock objects are an essential part of writing unit tests. They allow you to replace the real implementations of your services with objects that simulate their behavior, giving you more control over your test environment. With Parsley’s new generate mocks command, you can generate mocks that trace method calls, verify parameters, and count invocations without writing additional boilerplate code."]},{"l":"Defining a Service Interface","p":["Let's begin with a simple service interface, Greeter, which defines two methods: SayHello and SayNothing.","By adding the //go:generate directive at the top, we instruct Parsley’s CLI to generate a mock implementation for this interface."]},{"l":"The Generated Mock Code","p":["After running the parsley-cli generate mocks command, Parsley generates the following mock implementation code. A mock.g.go file is automatically created, and any manual changes will be overwritten if the command is rerun."]},{"l":"Configuring Mocks in Tests","p":["Once the mock has been generated, it can be used in your tests as a drop-in replacement for the actual service. You can configure its behavior by overriding the functions for each method in the interface.","Here’s an example of how to test the GreeterMock type by configuring the behavior of SayHello and using Parsley’s Verify assertion helpers:"]},{"i":"verifying-method-calls-and-arguments","l":"Verifying Method Calls (and Arguments)","p":["The generated mocks automatically trace method calls and allow you to verify how often methods were invoked and with which arguments. Parsley provides a set of powerful assertion helpers to verify method calls:"]},{"l":"Counter verification functions","p":["TimesOnce: Verifies that a method was called exactly once.","TimesNever: Verifies that a method was never called.","TimesExactly: Verifies that a method was called exactly n times."]},{"l":"Argument matching","p":["Exact: Matches arguments exactly.","IsAny: Matches any given argument - use this as a placeholder.","For example, in the test case above:","The mock verifies that SayHello was called once with the exact argument John.","The mock checks that SayHello was never called with the argument Jane.","Lastly, it verifies that SayHello was called exactly twice in total.","Note: You can also provide custom TimesFunc and ArgMatch callbacks to evaluate counter values and method call parameters."]},{"l":"Conclusion","p":["With the new generate mocks command, Parsley makes it easy to create fully configurable and traceable mock objects for your services.","The mock generation feature is especially useful for writing tests, where you want to simulate different service behaviors, verify method calls, and ensure your components interact correctly with each other."]},{"i":"using-parsleys-generator-commands-without-runtime-dependency-injection","l":"Using Parsley’s generator commands without Runtime Dependency Injection","p":["Parsley’s generator commands, like the generate mocks command, can be used independently of Parsley’s runtime dependency injection. This flexibility allows developers to leverage powerful code generation features, such as creating mock implementations for interfaces, without adopting Parsley’s full DI system.","For instance, you may prefer to manually wire your dependencies in a traditional Go setup while still using Parsley’s mock generation capabilities for testing. This makes Parsley a versatile tool that can be integrated into various workflows, whether or not you choose to use runtime DI for your projects."]}],[{"l":"Advanced Dependency Injection with generated Proxies","p":["The Parsley CLI introduces a powerful feature for advanced dependency injection through its generate proxy command. This command, combined with //go:generate annotations, automatically generates proxy services and interfaces for your service contracts.","Use the following command to install the parsley-cli utility:"]},{"l":"Example","p":["Consider a Greeter interface and its implementation. By adding the //go:generate parsley-cli generate proxy annotation in your code, you enable the Parsley CLI to generate a corresponding proxy class. This proxy wraps the original service and allows for method interception, enabling additional behavior to be injected around service calls.","The code generator creates a greeter.proxy.g.go that contains a type that also implements the Greeter interface and thus can be used as drop-in replacements for the actual Greeter service. The proxy type supports intercepting method calls, allowing custom logic to be added before or after a method is invoked.","In this example, the GreeterProxy wraps the Greeter service, and any registered MethodInterceptor services can act upon method invocations, adding custom behavior such as logging, validation, or modification of method parameters.","The boilerplate code to register the generated proxies and a custom MethodInterceptor for logging purposes looks as follows:"]},{"l":"Benefits and use cases","p":["Separation of Concerns: Proxies can separate core business logic from cross-cutting concerns like logging or security.","Dynamic Interception: Proxies allow dynamic interception of method calls, making adding or modifying behavior easier without altering the service's core logic.","Extensibility: This feature provides a flexible mechanism to extend the functionality of services, making it ideal for scenarios where services require dynamic behavior adjustments. This advanced feature of Parsley CLI simplifies complex dependency injection scenarios, providing developers with robust tools to manage and extend service behavior effortlessly."]}],[{"i":"walkthrough-parsley-integration-with-gofiber","l":"Walkthrough: Parsley Integration with GoFiber","p":["This guide demonstrates how to integrate the Parsley dependency injection framework with the GoFiber web framework. By following this example, you'll learn how to set up a GoFiber application with dependency injection managed by Parsley, making your codebase more modular, testable, and maintainable."]},{"l":"Project Structure","p":["The code for this example can be found at examples/integrations/gofiber it has the following structure:","This article describes the project's structure and the purpose of each module in detail."]},{"l":"Main Application","p":["The main entry point of the application is in the cmd/main.go file:","In this file, the RunParsleyApplication function is called to bootstrap the application. It initializes the Parsley application context and configures the GoFiber server with the necessary services and route handlers."]},{"l":"Modules","p":["The modules package contains the service configurations required to set up the GoFiber application. The fiber_module.go module configures the Fiber application and registers it as a singleton service within the Parsley framework:","This configuration ensures that the Fiber instance is initialized and available for dependency injection."]},{"l":"Services","p":["Next, the internal/services/greeter.go file defines the Greeter service, which returns a greeting message based on the provided name and politeness flag.","The Greeter service is registered by the greeter_module.go module."]},{"l":"Route Handlers","p":["In this example, route handlers are also services, structs implementing the RouteHandler interface, which register one or more route handlers with the Fiber application. The interface is defined as follows:","The internal/route_handlers/greeter.go file registers the route handler for the /say-hello endpoint, which returns a greeting message based on the query parameters provided in the request. The logic for the message generation is handled by the Greeter service, which is injected into the NewGreeterRouteHandler method.","The route_handler_module.go file handles the registration of the RouteHandler services themselves.","This configuration ensures that all route handlers the application requires are correctly registered and injected into the Fiber application instance. Since the application service expects a set of route handler services, the RegisterList method must be used to register a list activator for the RouteHandler type."]},{"l":"Application Logic","p":["The internal/application.go file contains the main application service:","This file defines the parsleyApplication struct as the main application service. It registers the route handlers and starts the GoFiber server on port 5502. However, aspects like having the listener port configurable or a graceful server shutdown are omitted here, but they could be addressed here as well."]},{"l":"Running the Application","p":["To run the application, navigate to the root directory and execute the following command:","As configured in the code, the application will start a GoFiber server on http://localhost:5502. You can then access the /say-hello endpoint:","This should return:","For more details on Parsley, check out the Parsley GitHub repository."]}]]